

├── .claude
    ├── commands
    │   ├── execute-prp.md
    │   └── generate-prp.md
    └── settings.local.json
├── .devcontainer
    └── setup_python_claude
    │   └── devcontainer.json
├── .env.example
├── .github
    ├── dependabot.yaml
    ├── scripts
    │   ├── create_pr.sh
    │   └── delete_branch_pr_tag.sh
    └── workflows
    │   ├── bump-my-version.yaml
    │   ├── codeql.yaml
    │   ├── generate-deploy-mkdocs-ghpages.yaml
    │   ├── links-fail-fast.yaml
    │   ├── pytest.yaml
    │   ├── ruff.yaml
    │   ├── summarize-jobs-reusable.yaml
    │   └── write-llms-txt.yaml
├── .gitignore
├── .gitmessage
├── .vscode
    ├── extensions.json
    └── settings.json
├── AGENTS.md
├── CHANGELOG.md
├── CLAUDE.md
├── LICENSE
├── Makefile
├── README.md
├── assets
    └── images
    │   ├── example_execute_feature_mcp_server_PRP_update_pyproject.PNG
    │   ├── example_execute_feature_mcp_server_PRP_update_pyproject_diff.PNG
    │   ├── example_execute_feature_mcp_server_created.PNG
    │   ├── example_generate_feature_mcp_server_PRP.PNG
    │   ├── sequence_diagram.png
    │   └── sequence_diagram.svg
├── context
    ├── PRPs
    │   ├── feature_1_mcp_server.md
    │   ├── feature_2_mcp_client.md
    │   └── feature_3_streamlit_gui.md
    ├── examples
    │   ├── client_get_date_input.json
    │   ├── client_get_weather_input.json
    │   ├── client_invalid_tool.json
    │   ├── client_roll_dice_input.json
    │   ├── features
    │   │   ├── feature_1_mcp_server.md
    │   │   ├── feature_2_mcp_client.md
    │   │   └── feature_3_streamlit_gui.md
    │   ├── get_date_example.json
    │   ├── get_weather_example.json
    │   ├── roll_dice_example.json
    │   ├── streamlit_error_handling.json
    │   ├── streamlit_get_date_interaction.json
    │   ├── streamlit_get_weather_interaction.json
    │   └── streamlit_roll_dice_interaction.json
    └── templates
    │   ├── feature_base.md
    │   └── prp_base.md
├── docs
    ├── architecture
    │   └── sequence_diagram.mermaid
    └── llms.txt
├── mkdocs.yaml
├── pyproject.toml
├── src
    ├── __init__.py
    ├── gui
    │   ├── __init__.py
    │   ├── app.py
    │   ├── components
    │   │   ├── __init__.py
    │   │   ├── connection.py
    │   │   ├── history.py
    │   │   └── tool_forms.py
    │   ├── models
    │   │   ├── __init__.py
    │   │   └── gui_models.py
    │   └── utils
    │   │   ├── __init__.py
    │   │   ├── formatting.py
    │   │   └── validation.py
    ├── main.py
    ├── mcp_client
    │   ├── __init__.py
    │   ├── cli.py
    │   ├── client.py
    │   ├── models
    │   │   ├── __init__.py
    │   │   └── responses.py
    │   └── transport.py
    ├── mcp_server
    │   ├── __init__.py
    │   ├── models
    │   │   ├── __init__.py
    │   │   └── requests.py
    │   ├── server.py
    │   └── tools
    │   │   ├── __init__.py
    │   │   ├── base.py
    │   │   ├── date_time.py
    │   │   ├── dice.py
    │   │   └── weather.py
    └── py.typed
├── tests
    ├── __init__.py
    ├── fixtures
    │   ├── __init__.py
    │   └── mcp_messages.py
    ├── test_cli.py
    ├── test_gui.py
    ├── test_mcp_client.py
    ├── test_mcp_server.py
    └── test_tools
    │   ├── __init__.py
    │   ├── test_date_time.py
    │   ├── test_dice.py
    │   └── test_weather.py
└── uv.lock


/.claude/commands/execute-prp.md:
--------------------------------------------------------------------------------
 1 | # Execute Product Requirements Prompt (PRP)
 2 | 
 3 | Implement a feature using using the PRP file.
 4 | 
 5 | ## PRP File: $ARGUMENTS
 6 | 
 7 | ## Execution Process
 8 | 
 9 | 1. **Load PRP**
10 |    - Read the specified PRP file
11 |    - Understand all context and requirements
12 |    - Follow all instructions in the PRP and extend the research if needed
13 |    - Ensure you have all needed context to implement the PRP fully
14 |    - Do more web searches and codebase exploration as needed
15 | 
16 | 2. **ULTRATHINK**
17 |    - Think hard before you execute the plan. Create a comprehensive plan addressing all requirements.
18 |    - Break down complex tasks into smaller, manageable steps using your todos tools.
19 |    - Use the TodoWrite tool to create and track your implementation plan.
20 |    - Identify implementation patterns from existing code to follow.
21 | 
22 | 3. **Execute the plan**
23 |    - Execute the PRP
24 |    - Implement all the code
25 | 
26 | 4. **Validate**
27 |    - Run each validation command
28 |    - Fix any failures
29 |    - Re-run until all pass
30 | 
31 | 5. **Complete**
32 |    - Ensure all checklist items done
33 |    - Run final validation suite
34 |    - Report completion status
35 |    - Read the PRP again to ensure you have implemented everything
36 | 
37 | 6. **Reference the PRP**
38 |    - You can always reference the PRP again if needed
39 | 
40 | Note: If validation fails, use error patterns in PRP to fix and retry.
41 | 


--------------------------------------------------------------------------------
/.claude/commands/generate-prp.md:
--------------------------------------------------------------------------------
 1 | # Create Product Requirements Prompt (PRP)
 2 | 
 3 | ## Feature file: $ARGUMENTS
 4 | 
 5 | Generate a complete PRP (Product Requirements Prompt) for general feature implementation with thorough research. Ensure context is passed to the AI agent to enable self-validation and iterative refinement. Read the feature file first to understand what needs to be created, how the examples provided help, and any other considerations.
 6 | 
 7 | The AI agent only gets the context you are appending to the PRP and training data. Assume the AI agent has access to the codebase and the same knowledge cutoff as you, so its important that your research findings are included or referenced in the PRP. The Agent has Websearch capabilities, so pass urls to documentation and examples.
 8 | 
 9 | - Use `/context/PRPs` as `$base_path`
10 | - Extract only the filename from `$ARGUMENTS` into `$file_name`
11 | 
12 | ## Research Process
13 | 
14 | 1. **Codebase Analysis**
15 |    - Search for similar features/patterns in the codebase
16 |    - Identify files to reference in PRP
17 |    - Note existing conventions to follow
18 |    - Check test patterns for validation approach
19 | 
20 | 2. **External Research**
21 |    - Search for similar features/patterns online
22 |    - Library documentation (include specific URLs)
23 |    - Implementation examples (GitHub/StackOverflow/blogs)
24 |    - Best practices and common pitfalls
25 | 
26 | 3. **User Clarification** (if needed)
27 |    - Specific patterns to mirror and where to find them?
28 |    - Integration requirements and where to find them?
29 | 
30 | ## PRP Generation
31 | 
32 | - Use `${base_path}/templates/prp_base.md` in the base folder as template
33 | 
34 | ### Critical Context to Include and pass to the AI agent as part of the PRP
35 | 
36 | - **Documentation**: URLs with specific sections
37 | - **Code Examples**: Real snippets from codebase
38 | - **Gotchas**: Library quirks, version issues
39 | - **Patterns**: Existing approaches to follow
40 | 
41 | ### Implementation Blueprint
42 | 
43 | - Start with pseudocode showing approach
44 | - Reference real files for patterns
45 | - Include error handling strategy
46 | - list tasks to be completed to fullfill the PRP in the order they should be completed
47 | 
48 | ### Validation Gates (Must be Executable) eg for python
49 | 
50 | ```bash
51 | # Syntax/Style
52 | make ruff
53 | make check_types
54 | 
55 | # Unit Tests
56 | make coverage_all
57 | ```
58 | 
59 | ***CRITICAL AFTER YOU ARE DONE RESEARCHING AND EXPLORING THE CODEBASE BEFORE YOU START WRITING THE PRP***
60 | 
61 | ***ULTRATHINK ABOUT THE PRP AND PLAN YOUR APPROACH THEN START WRITING THE PRP***
62 | 
63 | ## Output
64 | 
65 | - Save the result to `${base_path}/${file_name}`
66 | 
67 | ## Quality Checklist
68 | 
69 | - [ ] All necessary context included
70 | - [ ] Validation gates are executable by AI
71 | - [ ] References existing patterns
72 | - [ ] Clear implementation path
73 | - [ ] Error handling documented
74 | 
75 | Score the PRP on a scale of 1-10 (confidence level to succeed in one-pass implementation using claude codes)
76 | 
77 | Remember: The goal is one-pass implementation success through comprehensive context.
78 | 


--------------------------------------------------------------------------------
/.claude/settings.local.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "permissions": {
 3 |     "allow": [
 4 |       "Bash(cat:*)",
 5 |       "Bash(find:*)",
 6 |       "Bash(git:diff*)",
 7 |       "Bash(git:log*)",
 8 |       "Bash(git:status*)",
 9 |       "Bash(grep:*)",
10 |       "Bash(ls:*)",
11 |       "Bash(mkdir:*)",
12 |       "Bash(source:*)",
13 |       "Bash(touch:*)",
14 |       "Bash(tree:*)",
15 |       "Bash(uv:run*)", 
16 |       "Edit(AGENTS.md)",
17 |       "Edit(docs/**/*.md)",
18 |       "Edit(src/**/*.py)",
19 |       "Edit(src/**/*.json)",
20 |       "Edit(tests/**/*.py)",
21 |       "WebFetch(domain:docs.anthropic.com)"
22 |     ],
23 |     "deny": [
24 |       "Bash(mv:*)",
25 |       "Bash(rm:*)",
26 |       "Edit(CLAUDE.md"
27 |     ]
28 |   }
29 | }


--------------------------------------------------------------------------------
/.devcontainer/setup_python_claude/devcontainer.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "setup_python_claude",
 3 |   "image": "mcr.microsoft.com/vscode/devcontainers/python:3.13",
 4 |   "features": {
 5 |     "ghcr.io/devcontainers/features/node:1": {}
 6 |   },
 7 |   "customizations": {
 8 |     "vscode": {
 9 |       "extensions": [
10 |         "anthropic.claude-code"
11 |       ]
12 |     }
13 |   },
14 |   "postCreateCommand": "make setup_python_claude"
15 | }


--------------------------------------------------------------------------------
/.env.example:
--------------------------------------------------------------------------------
1 | ANTHROPIC_API_KEY="sk-abc-xyz"
2 | GEMINI_API_KEY="xyz"
3 | GITHUB_API_KEY="ghp_xyz"
4 | GROK_API_KEY="xai-xyz"
5 | HUGGINGFACE_API_KEY="hf_xyz"
6 | OPENROUTER_API_KEY="sk-or-v1-xyz"
7 | PERPLEXITY_API_KEY=""
8 | RESTACK_API_KEY="xyz"
9 | TOGETHER_API_KEY="xyz"


--------------------------------------------------------------------------------
/.github/dependabot.yaml:
--------------------------------------------------------------------------------
 1 | ---
 2 | # https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
 3 | version: 2
 4 | updates:
 5 |   - package-ecosystem: "pip"
 6 |     directory: "/"
 7 |     schedule:
 8 |       interval: "weekly"
 9 | ...
10 | 


--------------------------------------------------------------------------------
/.github/scripts/create_pr.sh:
--------------------------------------------------------------------------------
 1 | #!/bin/bash
 2 | # 1 base ref, 2 target ref, 3 title suffix
 3 | # 4 current version, 5 bumped
 4 | 
 5 | pr_title="PR $2 $3"
 6 | pr_body="PR automatically created from \`$1\` to bump from \`$4\` to \`$5\` on \`$2\`. Tag \`v$5\` will be created and has to be deleted manually if PR gets closed without merge."
 7 | 
 8 | gh pr create \
 9 |   --base $1 \
10 |   --head $2 \
11 |   --title "${pr_title}" \
12 |   --body "${pr_body}"
13 |   # --label "bump"
14 | 


--------------------------------------------------------------------------------
/.github/scripts/delete_branch_pr_tag.sh:
--------------------------------------------------------------------------------
 1 | #!/bin/bash
 2 | # 1 repo, 2 target ref, 3 current version
 3 | 
 4 | tag_to_delete="v$3"
 5 | branch_del_api_call="repos/$1/git/refs/heads/$2"
 6 | del_msg="'$2' force deletion attempted."
 7 | close_msg="Closing PR '$2' to rollback after failure"
 8 | 
 9 | echo "Tag $tag_to_delete for $del_msg"
10 | git tag -d "$tag_to_delete"
11 | echo "PR for $del_msg"
12 | gh pr close "$2" --comment "$close_msg"
13 | echo "Branch $del_msg"
14 | gh api "$branch_del_api_call" -X DELETE && \
15 |   echo "Branch without error return deleted."


--------------------------------------------------------------------------------
/.github/workflows/bump-my-version.yaml:
--------------------------------------------------------------------------------
  1 | name: bump-my-version
  2 | 
  3 | on:
  4 |   # pull_request:
  5 |   #  types: [closed]
  6 |   #  branches: [main]
  7 |   workflow_dispatch:
  8 |     inputs:
  9 |       bump_type:
 10 |         description: '[major|minor|patch]'
 11 |         required: true
 12 |         default: 'patch'
 13 |         type: choice
 14 |         options:
 15 |         - 'major'
 16 |         - 'minor'
 17 |         - 'patch'
 18 | 
 19 | env:
 20 |   BRANCH_NEW: "bump-${{ github.run_number }}-${{ github.ref_name }}"
 21 |   SKIP_PR_HINT: "[skip ci bump]"
 22 |   SCRIPT_PATH: ".github/scripts"
 23 | 
 24 | jobs:
 25 |   bump_my_version:
 26 |     # TODO bug? currently resulting in: Unrecognized named-value: 'env'.
 27 |     # https://stackoverflow.com/questions/61238849/github-actions-if-contains-function-not-working-with-env-variable/61240761
 28 |     # if: !contains(
 29 |     #      github.event.pull_request.title,
 30 |     #      ${{ env.SKIP_PR_HINT }}
 31 |     #    )
 32 |     # TODO check for PR closed by bot to avoid PR creation loop
 33 |     # github.actor != 'github-actions'
 34 |     if: >
 35 |         github.event_name == 'workflow_dispatch' ||
 36 |         ( github.event.pull_request.merged == true &&
 37 |         github.event.pull_request.closed_by != 'github-actions' )
 38 |     runs-on: ubuntu-latest
 39 |     outputs:
 40 |       branch_new: ${{ steps.create_branch.outputs.branch_new }}
 41 |       summary_data: ${{ steps.set_summary.outputs.summary_data }}
 42 |     permissions:
 43 |       actions: read
 44 |       checks: write
 45 |       contents: write
 46 |       pull-requests: write
 47 |     steps:
 48 | 
 49 |       - name: Checkout repo
 50 |         uses: actions/checkout@v4
 51 |         with:
 52 |           fetch-depth: 1
 53 | 
 54 |       - name: Set git cfg and create branch
 55 |         id: create_branch
 56 |         run: |
 57 |           git config user.email "github-actions@users.noreply.github.com"
 58 |           git config user.name "github-actions[bot]"
 59 |           git checkout -b "${{ env.BRANCH_NEW }}"
 60 |           echo "branch_new=${{ env.BRANCH_NEW }}" >> $GITHUB_OUTPUT
 61 | 
 62 |       - name: Bump version
 63 |         id: bump
 64 |         uses: callowayproject/bump-my-version@0.29.0
 65 |         env:
 66 |           BUMPVERSION_TAG: "true"
 67 |         with:
 68 |           args: ${{ inputs.bump_type }}
 69 |           branch: ${{ env.BRANCH_NEW }}
 70 | 
 71 |       - name: "Create PR '${{ env.BRANCH_NEW }}'"
 72 |         if: steps.bump.outputs.bumped == 'true'
 73 |         env:
 74 |           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 75 |         run: |
 76 |           src="${{ env.SCRIPT_PATH }}/create_pr.sh"
 77 |           chmod +x "$src"
 78 |           $src "${{ github.ref_name }}" "${{ env.BRANCH_NEW }}" "${{ env.SKIP_PR_HINT }}" "${{ steps.bump.outputs.previous-version }}" "${{ steps.bump.outputs.current-version }}"
 79 | 
 80 |       - name: Delete branch, PR and tag in case of failure or cancel
 81 |         if: failure() || cancelled()
 82 |         env:
 83 |           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 84 |         run: |
 85 |           src="${{ env.SCRIPT_PATH }}/delete_branch_pr_tag.sh"
 86 |           chmod +x "$src"
 87 |           $src "${{ github.repository }}" "${{ env.BRANCH_NEW }}" "${{ steps.bump.outputs.current-version }}"
 88 | 
 89 |       - name: Set summary data
 90 |         id: set_summary
 91 |         if: ${{ always() }}
 92 |         run: echo "summary_data=${GITHUB_STEP_SUMMARY}" >> $GITHUB_OUTPUT
 93 |   
 94 |   generate_summary:
 95 |     name: Generate Summary Report 
 96 |     if: ${{ always() }}
 97 |     needs: bump_my_version
 98 |     uses: ./.github/workflows/summarize-jobs-reusable.yaml
 99 |     with:
100 |       branch_to_summarize: ${{ needs.bump_my_version.outputs.branch_new }}
101 |       summary_data: ${{ needs.bump_my_version.outputs.summary_data }}
102 | 


--------------------------------------------------------------------------------
/.github/workflows/codeql.yaml:
--------------------------------------------------------------------------------
 1 | ---
 2 | # https://github.blog/changelog/2023-01-18-code-scanning-codeql-action-v1-is-now-deprecated/
 3 | name: "CodeQL"
 4 | 
 5 | on:
 6 |   push:
 7 |   pull_request:
 8 |     types: [closed]
 9 |     branches: [ main ]
10 |   schedule:
11 |     - cron: '27 11 * * 0'
12 |   workflow_dispatch:
13 | 
14 | jobs:
15 |   analyze:
16 |     name: Analyze
17 |     runs-on: ubuntu-latest
18 |     permissions:
19 |       actions: read
20 |       contents: read
21 |       security-events: write
22 | 
23 |     steps:
24 |     - name: Checkout repository
25 |       uses: actions/checkout@v4
26 | 
27 |     - name: Initialize CodeQL
28 |       uses: github/codeql-action/init@v3
29 |       with:
30 |         languages: python
31 | 
32 |     - name: Autobuild
33 |       uses: github/codeql-action/autobuild@v3
34 |     # if autobuild fails
35 |     #- run: |
36 |     #   make bootstrap
37 |     #   make release
38 | 
39 |     - name: Perform CodeQL Analysis
40 |       uses: github/codeql-action/analyze@v3
41 |     #- name: sarif
42 |     #  uses: github/codeql-action/upload-sarif@v2
43 | ...
44 | 


--------------------------------------------------------------------------------
/.github/workflows/generate-deploy-mkdocs-ghpages.yaml:
--------------------------------------------------------------------------------
  1 | ---
  2 | name: Deploy Docs
  3 | 
  4 | on:
  5 |   pull_request:
  6 |     types: [closed]
  7 |     branches: [main]
  8 |   workflow_dispatch:
  9 | 
 10 | env:
 11 |   DOCSTRINGS_FILE: "docstrings.md"
 12 |   DOC_DIR: "docs"
 13 |   SRC_DIR: "src"
 14 |   SITE_DIR: "site"
 15 |   IMG_DIR: "assets/images"
 16 | 
 17 | jobs:
 18 |   build-and-deploy:
 19 |     runs-on: ubuntu-latest
 20 |     permissions:
 21 |       contents: read
 22 |       pages: write
 23 |       id-token: write
 24 |     environment:
 25 |       name: github-pages
 26 |     steps:
 27 | 
 28 |     - name: Checkout the repository
 29 |       uses: actions/checkout@v4.0.0
 30 |       with:
 31 |         ref:
 32 |           ${{
 33 |             github.event.pull_request.merged == true &&
 34 |             'main' ||
 35 |             github.ref_name
 36 |           }}
 37 |         fetch-depth: 0
 38 | 
 39 |     - uses: actions/configure-pages@v5.0.0
 40 | 
 41 |     # caching instead of actions/cache@v4.0.0
 42 |     # https://docs.astral.sh/uv/guides/integration/github/#caching
 43 |     - name: Install uv with cache dependency glob
 44 |       uses: astral-sh/setup-uv@v5.0.0
 45 |       with:
 46 |         enable-cache: true
 47 |         cache-dependency-glob: "uv.lock"
 48 | 
 49 |     # setup python from pyproject.toml using uv
 50 |     # instead of using actions/setup-python@v5.0.0
 51 |     # https://docs.astral.sh/uv/guides/integration/github/#setting-up-python
 52 |     - name: "Set up Python"
 53 |       run: uv python install
 54 | 
 55 |     - name: Install only doc deps
 56 |       run: uv sync --only-group docs # --frozen
 57 | 
 58 |     - name: Get repo info and stream into mkdocs.yaml
 59 |       id: repo_info
 60 |       run: |
 61 |         REPO_INFO=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
 62 |           -H "Accept: application/vnd.github.v3+json" \
 63 |           https://api.github.com/repos/${{ github.repository }})
 64 |         REPO_URL="${{ github.server_url }}/${{ github.repository }}"
 65 |         REPO_URL=$(echo ${REPO_URL} | sed 's|/|\\/|g')
 66 |         SITE_NAME=$(sed '1!d' README.md | sed '0,/# /{s/# //}')
 67 |         SITE_DESC=$(echo $REPO_INFO | jq -r .description)
 68 |         sed -i "s/<gha_sed_repo_url_here>/${REPO_URL}/g" mkdocs.yaml
 69 |         sed -i "s/<gha_sed_site_name_here>/${SITE_NAME}/g" mkdocs.yaml
 70 |         sed -i "s/<gha_sed_site_description_here>/${SITE_DESC}/g" mkdocs.yaml
 71 | 
 72 |     - name: Copy text files to be included
 73 |       run: |
 74 |         CFG_PATH="src/app/config"
 75 |         mkdir -p "${DOC_DIR}/${CFG_PATH}"
 76 |         cp README.md "${DOC_DIR}/index.md"
 77 |         cp CHANGELOG.md LICENSE "${DOC_DIR}"
 78 |         # Auxiliary files
 79 |         cp .env.example "${DOC_DIR}"
 80 | 
 81 |     - name: Generate code docstrings concat file
 82 |       run: |
 83 |         PREFIX="::: "
 84 |         find "${SRC_DIR}" -type f -name "*.py" \
 85 |           -type f -not -name "__*__*" -printf "%P\n" | \
 86 |           sed 's/\//./g' | sed 's/\.py$//' | \
 87 |           sed "s/^/${PREFIX}/" | sort > \
 88 |           "${DOC_DIR}/${DOCSTRINGS_FILE}"
 89 | 
 90 |     - name: Build documentation
 91 |       run: uv run --locked --only-group docs mkdocs build
 92 | 
 93 |     - name: Copy image files to be included
 94 |       run: |
 95 |         # copy images, mkdocs does not by default
 96 |         # mkdocs also overwrites pre-made directories
 97 |         dir="${{ env.SITE_DIR }}/${{ env.IMG_DIR }}"
 98 |         if [ -d "${{ env.IMG_DIR }}" ]; then
 99 |           mkdir -p "${dir}"
100 |           cp "${{ env.IMG_DIR }}"/* "${dir}"
101 |         fi
102 | 
103 | #    - name: Push to gh-pages
104 | #      run: uv run mkdocs gh-deploy --force
105 | 
106 |     - name: Upload artifact
107 |       uses: actions/upload-pages-artifact@v3.0.0
108 |       with:
109 |         path: "${{ env.SITE_DIR }}"
110 | 
111 |     - name: Deploy to GitHub Pages
112 |       id: deployment
113 |       uses: actions/deploy-pages@v4.0.0
114 | ...
115 | 


--------------------------------------------------------------------------------
/.github/workflows/links-fail-fast.yaml:
--------------------------------------------------------------------------------
 1 | ---
 2 | # https://github.com/lycheeverse/lychee-action
 3 | # https://github.com/marketplace/actions/lychee-broken-link-checker
 4 | name: "Link Checker"
 5 | 
 6 | on:
 7 |   workflow_dispatch:
 8 |   push:
 9 |     branches-ignore: [main]
10 |   pull_request:
11 |     types: [closed]
12 |     branches: [main]
13 |   schedule:
14 |     - cron: "00 00 * * 0"
15 | 
16 | jobs:
17 |   linkChecker:
18 |     runs-on: ubuntu-latest
19 |     permissions:
20 |       issues: write
21 | 
22 |     steps:
23 |       - uses: actions/checkout@v4
24 | 
25 |       - name: Link Checker
26 |         id: lychee
27 |         uses: lycheeverse/lychee-action@v2
28 | 
29 |       - name: Create Issue From File
30 |         if: steps.lychee.outputs.exit_code != 0
31 |         uses: peter-evans/create-issue-from-file@v5
32 |         with:
33 |           title: lychee Link Checker Report
34 |           content-filepath: ./lychee/out.md
35 |           labels: report, automated issue
36 | ...
37 | 


--------------------------------------------------------------------------------
/.github/workflows/pytest.yaml:
--------------------------------------------------------------------------------
 1 | name: pytest
 2 | 
 3 | on:
 4 |   workflow_dispatch:
 5 | 
 6 | jobs:
 7 |   test:
 8 |     runs-on: ubuntu-latest
 9 |     steps:
10 |       - name: Checkout repository
11 |         uses: actions/checkout@v4
12 | 
13 |       - name: Set up Python
14 |         uses: actions/setup-python@v4
15 |         with:
16 |           python-version: '3.12'
17 | 
18 |       - name: Install dependencies
19 |         run: |
20 |           python -m pip install --upgrade pip
21 |           pip install pytest
22 | 
23 |       - name: Run tests
24 |         run: pytest
25 | 


--------------------------------------------------------------------------------
/.github/workflows/ruff.yaml:
--------------------------------------------------------------------------------
 1 | ---
 2 | # https://github.com/astral-sh/ruff-action
 3 | # https://github.com/astral-sh/ruff
 4 | name: ruff
 5 | on: 
 6 |   push:
 7 |   pull_request:
 8 |     types: [closed]
 9 |     branches: [main]
10 |   schedule:
11 |     - cron: "0 0 * * 0"
12 |   workflow_dispatch:
13 | jobs:
14 |   ruff:
15 |     runs-on: ubuntu-latest
16 |     steps:
17 |       - uses: actions/checkout@v4
18 |       - uses: astral-sh/ruff-action@v3
19 | ...
20 | 


--------------------------------------------------------------------------------
/.github/workflows/summarize-jobs-reusable.yaml:
--------------------------------------------------------------------------------
  1 | ---
  2 | # https://ecanarys.com/supercharging-github-actions-with-job-summaries-and-pull-request-comments/
  3 | # FIXME currently bug in gha summaries ? $GITHUB_STEP_SUMMARY files are empty
  4 | # https://github.com/orgs/community/discussions/110283
  5 | # https://github.com/orgs/community/discussions/67991
  6 | # Possible workaround
  7 | # echo ${{ fromJSON(step).name }}" >> $GITHUB_STEP_SUMMARY
  8 | # echo ${{ fromJSON(step).outcome }}" >> $GITHUB_STEP_SUMMARY
  9 | # echo ${{ fromJSON(step).conclusion }}"
 10 | 
 11 | name: Summarize workflow jobs
 12 | 
 13 | on:
 14 |   workflow_call:
 15 |     outputs:
 16 |       summary:
 17 |         description: "Outputs summaries of jobs in a workflow"
 18 |         value: ${{ jobs.generate_summary.outputs.summary }}
 19 |     inputs:
 20 |       branch_to_summarize:
 21 |         required: false
 22 |         default: 'main'
 23 |         type: string
 24 |       summary_data:
 25 |         required: false
 26 |         type: string
 27 | 
 28 | jobs:
 29 |   generate_summary:
 30 |     name: Generate Summary
 31 |     runs-on: ubuntu-latest
 32 |     permissions:
 33 |       contents: read
 34 |       actions: read
 35 |       checks: read
 36 |       pull-requests: none
 37 |     outputs:
 38 |       summary: ${{ steps.add_changed_files.outputs.summary }}
 39 |     steps:
 40 | 
 41 |       - name: Add general information
 42 |         id: general_info
 43 |         run: |
 44 |           echo "# Job Summaries" >> $GITHUB_STEP_SUMMARY
 45 |           echo "Job: `${{ github.job }}`" >> $GITHUB_STEP_SUMMARY
 46 |           echo "Date: $(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
 47 | 
 48 |       - name: Add step states
 49 |         id: step_states
 50 |         run: |
 51 |           echo "### Steps:" >> $GITHUB_STEP_SUMMARY
 52 |           # loop summary_data if valid json
 53 |           if jq -e . >/dev/null 2>&1 <<< "${{ inputs.summary_data }}"; then
 54 |             jq -r '
 55 |               .steps[]
 56 |               | select(.conclusion != null)
 57 |               | "- **\(.name)**: \(
 58 |                 if .conclusion == "success" then ":white_check_mark:"
 59 |                 elif .conclusion == "failure" then ":x:"
 60 |                 else ":warning:" end
 61 |               )"
 62 |             ' <<< "${{ inputs.summary_data }}" >> $GITHUB_STEP_SUMMARY
 63 |           else
 64 |             echo "Invalid JSON in summary data." >> $GITHUB_STEP_SUMMARY
 65 |           fi
 66 | 
 67 |       - name: Checkout repo
 68 |         uses: actions/checkout@v4
 69 |         with:
 70 |           ref: "${{ inputs.branch_to_summarize }}"
 71 |           fetch-depth: 0
 72 | 
 73 |       - name: Add changed files since last push
 74 |         id: add_changed_files
 75 |         run: |
 76 |           # Get the tags
 77 |           # Use disabled lines to get last two commits
 78 |           # current=$(git show -s --format=%ci HEAD)
 79 |           # previous=$(git show -s --format=%ci HEAD~1)
 80 |           # git diff --name-only HEAD^ HEAD >> $GITHUB_STEP_SUMMARY
 81 |           version_tag_regex="^v[0-9]+\.[0-9]+\.[0-9]+

quot; # v0.0.0 
 82 |           tags=$(git tag --sort=-version:refname | \
 83 |             grep -E "${version_tag_regex}" || echo "")
 84 | 
 85 |           # Get latest and previous tags
 86 |           latest_tag=$(echo "${tags}" | head -n 1)
 87 |           previous_tag=$(echo "${tags}" | head -n 2 | tail -n 1)
 88 | 
 89 |           echo "tags: latest '${latest_tag}', previous '${previous_tag}'"
 90 | 
 91 |           # Write to summary
 92 |           error_msg="No files to output. Tag not found:"
 93 |           echo ${{ steps.step_states.outputs.summary }} >> $GITHUB_STEP_SUMMARY
 94 |           echo "## Changed files on '${{ inputs.branch_to_summarize }}'" >> $GITHUB_STEP_SUMMARY
 95 | 
 96 |           if [ -z "${latest_tag}" ]; then
 97 |             echo "${error_msg} latest" >> $GITHUB_STEP_SUMMARY
 98 |           elif [ -z "${previous_tag}" ]; then
 99 |             echo "${error_msg} previous" >> $GITHUB_STEP_SUMMARY
100 |           elif [ "${latest_tag}" == "${previous_tag}" ]; then
101 |             echo "Latest and previous tags are the same: '${latest_tag}'" >> $GITHUB_STEP_SUMMARY
102 |           else
103 |             # Get commit dates and hashes
104 |             latest_date=$(git log -1 --format=%ci $latest_tag)
105 |             previous_date=$(git log -1 --format=%ci $previous_tag)
106 |             current_hash=$(git rev-parse --short $latest_tag)
107 |             previous_hash=$(git rev-parse --short $previous_tag)
108 | 
109 |             # Append summary to the job summary
110 |             echo "Latest Tag Commit: '${latest_tag}' (${current_hash}) ${latest_date}" >> $GITHUB_STEP_SUMMARY
111 |             echo "Previous Tag Commit: '${previous_tag}' (${previous_hash}) ${previous_date}" >> $GITHUB_STEP_SUMMARY
112 |             echo "Files changed:" >> $GITHUB_STEP_SUMMARY
113 |             echo '```' >> $GITHUB_STEP_SUMMARY
114 |             git diff --name-only $previous_tag..$latest_tag >> $GITHUB_STEP_SUMMARY
115 |             echo '```' >> $GITHUB_STEP_SUMMARY
116 |           fi
117 | 
118 |       - name: Output error message in case of failure or cancel
119 |         if: failure() || cancelled()
120 |         run: |
121 |           if [ "${{ job.status }}" == "cancelled" ]; then
122 |             out_msg="## Workflow was cancelled"
123 |           else
124 |             out_msg="## Error in previous step"
125 |           fi
126 |           echo $out_msg >> $GITHUB_STEP_SUMMARY
127 | ...


--------------------------------------------------------------------------------
/.github/workflows/write-llms-txt.yaml:
--------------------------------------------------------------------------------
 1 | # TODO use local installation of repo to text
 2 | # https://github.com/itsitgroup/repo2txt
 3 | name: Write repo llms.txt
 4 | 
 5 | on:
 6 |   push:
 7 |     branches: [main]
 8 |   workflow_dispatch:
 9 |     inputs:
10 |       LLMS_TXT_PATH:
11 |         description: 'Path to the directory to save llsm.txt'
12 |         required: true
13 |         default: 'docs'
14 |         type: string
15 |       LLMS_TXT_NAME:
16 |         description: 'Path to the directory to save llsm.txt'
17 |         required: true
18 |         default: 'llms.txt'
19 |         type: string
20 |       CONVERTER_URL:
21 |         description: '[uithub|gittodoc]'  # |repo2txt
22 |         required: true
23 |         default: 'uithub.com'
24 |         type: choice
25 |         options:
26 |         - 'uithub.com'
27 |         - 'gittodoc.com'
28 |         # - 'repo2txt.com'
29 | 
30 | jobs:
31 |   generate-file:
32 |     runs-on: ubuntu-latest
33 | 
34 |     steps:
35 |       - name: Checkout repo
36 |         uses: actions/checkout@v4
37 | 
38 |       - name: Construct and create llms.txt path
39 |         id: construct_and_create_llms_txt_path
40 |         run: |
41 |           LLMS_TXT_PATH="${{ inputs.LLMS_TXT_PATH }}"
42 |           LLMS_TXT_PATH="${LLMS_TXT_PATH:-docs}"
43 |           LLMS_TXT_NAME="${{ inputs.LLMS_TXT_NAME }}"
44 |           LLMS_TXT_NAME="${LLMS_TXT_NAME:-llms.txt}"
45 |           echo "LLMS_TXT_FULL=${LLMS_TXT_PATH}/${LLMS_TXT_NAME}" >> $GITHUB_OUTPUT
46 |           mkdir -p "${LLMS_TXT_PATH}"
47 | 
48 |       - name: Fetch TXT from URL
49 |         run: |
50 |           LLMS_TXT_FULL=${{ steps.construct_and_create_llms_txt_path.outputs.LLMS_TXT_FULL }}
51 |           URL="https://${{ inputs.CONVERTER_URL }}/${{ github.repository }}"
52 |           echo "Fetching content from: ${URL}"
53 |           echo "Saving content to: ${LLMS_TXT_FULL}"
54 |           curl -s "${URL}" > "${LLMS_TXT_FULL}"
55 | 
56 |       - name: Commit and push file
57 |         run: |
58 |           LLMS_TXT_FULL=${{ steps.construct_and_create_llms_txt_path.outputs.LLMS_TXT_FULL }}
59 |           commit_msg="feat(docs): Add/Update ${LLMS_TXT_FULL}, a flattened repo as single text file, inspired by [llmstxt.org](https://llmstxt.org/)."
60 |           git config user.name "github-actions"
61 |           git config user.email "github-actions@github.com"
62 |           git add "${LLMS_TXT_FULL}"
63 |           git commit -m "${commit_msg}"
64 |           git push
65 | 


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
 1 | # Python bytecode
 2 | __pycache__/
 3 | *.py[cod]
 4 | 
 5 | # environment
 6 | .venv/
 7 | *.env
 8 | 
 9 | # Distribution / packaging
10 | build/
11 | dist/
12 | *.egg-info/
13 | 
14 | # Testing
15 | .pytest_cache/
16 | .coverage
17 | 
18 | # Logs
19 | *.log
20 | /logs
21 | 
22 | # OS generated files
23 | .DS_Store
24 | Thumbs.db
25 | 
26 | # IDE specific files (adjust as needed)
27 | # .vscode/
28 | # .idea/
29 | 
30 | # mkdocs
31 | reference/
32 | site/
33 | 
34 | # linting
35 | .ruff_cache
36 | 
37 | # type checking
38 | .mypy_cache/
39 | 


--------------------------------------------------------------------------------
/.gitmessage:
--------------------------------------------------------------------------------
 1 | #<--- 72 characters --------------------------------------------------->
 2 | #
 3 | # Conventional Commits, semantic commit messages for humans and machines
 4 | # https://www.conventionalcommits.org/en/v1.0.0/
 5 | # Lint your conventional commits
 6 | # https://github.com/conventional-changelog/commitlint/tree/master/%40 \
 7 | #	commitlint/config-conventional
 8 | # Common types can be (based on Angular convention)
 9 | # build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test
10 | # https://github.com/conventional-changelog/commitlint/tree/master/%40
11 | # Footer
12 | # https://git-scm.com/docs/git-interpret-trailers
13 | #
14 | #<--- pattern --------------------------------------------------------->
15 | #
16 | # <feat|fix|build|chore|ci|docs|style|refactor|perf|test>[(Scope)][!]: \
17 | #	<description>
18 | # short description: <type>[(<scope>)]: <subject>
19 | #
20 | # ! after scope in header indicates breaking change
21 | #
22 | # [optional body]
23 | #
24 | # - with bullets points
25 | #
26 | # [optional footer(s)]
27 | #
28 | # [BREAKING CHANGE:, Refs:, Resolves:, Addresses:, Reviewed by:]
29 | #
30 | #<--- usage ----------------------------------------------------------->
31 | #
32 | # Set locally (in the repository)
33 | # `git config commit.template .gitmessage`
34 | #
35 | # Set globally
36 | # `git config --global commit.template .gitmessage`
37 | #
38 | #<--- 72 characters --------------------------------------------------->


--------------------------------------------------------------------------------
/.vscode/extensions.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "recommendations": [
 3 |         "charliermarsh.ruff",
 4 |         "davidanson.vscode-markdownlint",
 5 |         "donjayamanne.githistory",
 6 |         "editorconfig.editorconfig",
 7 |         "gruntfuggly.todo-tree",
 8 |         "mhutchie.git-graph",
 9 |         "PKief.material-icon-theme",
10 |         "redhat.vscode-yaml",
11 |         "tamasfe.even-better-toml",
12 |         "yzhang.markdown-all-in-one",
13 | 
14 |         "github.copilot",
15 |         "github.copilot-chat",
16 |         "github.vscode-github-actions",
17 |         "ms-azuretools.vscode-docker",
18 |         "ms-python.debugpy",
19 |         "ms-python.python",
20 |         "ms-python.vscode-pylance",
21 |         "ms-vscode.makefile-tools",
22 |     ]
23 | }


--------------------------------------------------------------------------------
/.vscode/settings.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "editor.lineNumbers": "on",
 3 |     "editor.wordWrap": "on",
 4 |     "explorer.confirmDelete": true,
 5 |     "files.autoSave": "onFocusChange",
 6 |     "git.autofetch": true,
 7 |     "git.enableSmartCommit": true,
 8 |     "makefile.configureOnOpen": false,
 9 |     "markdownlint.config": {
10 |         "MD024": false,
11 |         "MD033": false
12 |     },
13 |     "python.analysis.extraPaths": ["./venv/lib/python3.13/site-packages"],
14 |     "python.defaultInterpreterPath": "./.venv/bin/python",
15 |     "python.analysis.typeCheckingMode": "strict",
16 |     "python.analysis.diagnosticSeverityOverrides": {
17 |         "reportMissingTypeStubs": "none",
18 |         "reportUnknownMemberType": "none",
19 |         "reportUnknownVariableType": "none"
20 |     },
21 |     "redhat.telemetry.enabled": false
22 | }


--------------------------------------------------------------------------------
/AGENTS.md:
--------------------------------------------------------------------------------
  1 | # Agent instructions for `Agents-eval` repository
  2 | 
  3 | As proposed by [agentsmd.net](https://agentsmd.net/) and used by [wandb weave AGENTS.md](https://github.com/wandb/weave/blob/master/AGENTS.md).
  4 | 
  5 | ## Core Rules & AI Behavior
  6 | 
  7 | * When you learn something new about the codebase or introduce a new concept, **update this file (`AGENTS.md`)** to reflect the new knowledge. This is YOUR FILE! It should grow and evolve with you.
  8 | * If something doesn't make sense architecturally, from a developer experience standpoint, or product-wise, please add it to the **`Requests to Humans`** section below.
  9 | * Always follow the established coding patterns, conventions, and architectural decisions documented here and in the `docs/` directory.
 10 | * **Never assume missing context.** Ask questions if you are uncertain about requirements or implementation details.
 11 | * **Never hallucinate libraries or functions.** Only use known, verified Python packages listed in `pyproject.toml`.
 12 | * **Always confirm file paths and module names** exist before referencing them in code or tests.
 13 | * **Never delete or overwrite existing code** unless explicitly instructed to or as part of a documented refactoring task.
 14 | 
 15 | ## Architecture Overview
 16 | 
 17 | This is a multi-agent evaluation system for assessing agentic AI systems. The project uses **PydanticAI** as the core framework for agent orchestration and is designed for evaluation purposes, not for production agent deployment.
 18 | 
 19 | ### Data Flow
 20 | 
 21 | 1. User input → Manager Agent
 22 | 2. Manager delegates to Researcher Agent (with DuckDuckGo search)
 23 | 3. Researcher results → Analyst Agent for validation
 24 | 4. Validated data → Synthesizer Agent for report generation
 25 | 5. Results evaluated using configurable metrics
 26 | 
 27 | ### Key Dependencies
 28 | 
 29 | * **PydanticAI**: Agent framework and orchestration
 30 | * **uv**: Fast Python dependency management
 31 | * **Streamlit**: GUI framework
 32 | * **Ruff**: Code formatting and linting
 33 | * **MyPy**: Static type checking
 34 | 
 35 | ## Codebase Structure & Modularity
 36 | 
 37 | ### Main Components
 38 | 
 39 | * `src/app/`: The core application logic. This is where most of your work will be.
 40 |   * `main.py`: The main entry point for the CLI application.
 41 |   * `agents/agent_system.py`: Defines the multi-agent system, their interactions, and orchestration. **This is the central logic for agent behavior.**
 42 |   * `config/data_models.py`: Contains all **Pydantic** models that define the data contracts. This is a critical file for understanding data flow.
 43 |   * `config/config_chat.json`: Holds provider settings and system prompts for agents.
 44 |   * `config/config_eval.json`: Defines evaluation metrics and their weights.
 45 |   * `evals/metrics.py`: Implements the evaluation metrics.
 46 | * `src/gui/`: Contains the source code for the Streamlit GUI.
 47 | * `docs/`: Contains project documentation, including the Product Requirements Document (`PRD.md`) and the C4 architecture model.
 48 | * `tests/`: Contains all tests for the project, written using **pytest**.
 49 | 
 50 | ### Code Organization Rules
 51 | 
 52 | * **Never create a file longer than 500 lines of code.** If a file approaches this limit, refactor by splitting it into smaller, more focused modules or helper files.
 53 | * Organize code into clearly separated modules grouped by feature.
 54 | * Use clear, consistent, and absolute imports within packages.
 55 | 
 56 | ## Development Commands & Environment
 57 | 
 58 | ### Environment Setup
 59 | 
 60 | The project requirements are stated in `pyproject.toml`. Your development environment should be set up automatically using the provided `Makefile`, which configures the virtual environment.
 61 | 
 62 | * `make setup_dev`: Install all dev dependencies.
 63 | * `make setup_dev_claude`: Setup dev environment with Claude Code CLI.
 64 | * `make setup_dev_ollama`: Setup dev environment with Ollama local LLM.
 65 | 
 66 | ### Running the Application
 67 | 
 68 | * `make run_cli`: Run the CLI application.
 69 | * `make run_cli ARGS="--help"`: Run CLI with specific arguments.
 70 | * `make run_gui`: Run the Streamlit GUI.
 71 | 
 72 | ### Testing and Code Quality
 73 | 
 74 | * `make test_all`: Run all tests with pytest.
 75 | * `make coverage_all`: Run tests and generate a coverage report.
 76 | * `make ruff`: Format code and fix linting issues with Ruff.
 77 | * `make type_check`: Run mypy static type checking on `src/app/`.
 78 | 
 79 | ## Testing & Reliability
 80 | 
 81 | * **Always create Pytest unit tests** for new features (functions, classes, etc.).
 82 | * Tests must live in the `tests/` folder, mirroring the `src/app` structure.
 83 | * After updating any logic, check whether existing unit tests need to be updated. If so, do it.
 84 | * For each new feature, include at least:
 85 |   * 1 test for the expected use case (happy path).
 86 |   * 1 test for a known edge case.
 87 |   * 1 test for an expected failure case (e.g., invalid input).
 88 | * **To run a specific test file or function, use `uv run pytest` directly:**
 89 |   * `uv run pytest tests/test_specific_file.py`
 90 |   * `uv run pytest tests/test_specific_file.py::test_function`
 91 | 
 92 | ## Style, Patterns & Documentation
 93 | 
 94 | ### Coding Style
 95 | 
 96 | * **Use Pydantic** models in `src/app/config/data_models.py` for all data validation and data contracts. **Always use or update these models** when modifying data flows.
 97 | * Use the predefined error message functions from `src/app/utils/error_messages.py` for consistency.
 98 | * When writing complex logic, **add an inline `# Reason:` comment** explaining the *why*, not just the *what*.
 99 | * Comment non-obvious code to ensure it is understandable to a mid-level developer.
100 | 
101 | ### Documentation
102 | 
103 | * Write **docstrings for every function, class, and method** using the Google style format. This is critical as the documentation site is built automatically from docstrings.
104 | 
105 |     ```python
106 |     def example_function(param1: int) -> str:
107 |         """A brief summary of the function.
108 | 
109 |         Args:
110 |             param1 (int): A description of the first parameter.
111 | 
112 |         Returns:
113 |             str: A description of the return value.
114 |         """
115 |         return "example"
116 |     ```
117 | 
118 | * Update this `AGENTS.md` file when introducing new patterns or concepts.
119 | * Document significant architectural decisions in `docs/ADR.md`.
120 | * Document all significant changes, features, and bug fixes in `docs/CHANGELOG.md`.
121 | 
122 | ## Code Review & PR Guidelines
123 | 
124 | ### PR Requirements
125 | 
126 | * **Title Format**: Commit messages and PR titles must follow the **Conventional Commits** specification, as outlined in the `.gitmessage` template.
127 | * Provide detailed PR summaries including the purpose of the changes and the testing performed.
128 | 
129 | ### Pre-commit Checklist
130 | 
131 | 1. Run the linter and formatter: `make ruff`.
132 | 2. Ensure all tests pass: `make test_all`.
133 | 3. Ensure static type checks pass: `make type_check`.
134 | 4. Update documentation as described below.
135 | 
136 | ## Requests to Humans
137 | 
138 | This section contains a list of questions, clarifications, or tasks that AI agents wish to have humans complete or elaborate on.
139 | 
140 | * [ ] The `agent_system.py` module has a `NotImplementedError` for streaming with Pydantic model outputs. Please clarify the intended approach for streaming structured data.
141 | * [ ] The `llm_model_funs.py` module has `NotImplementedError` for the Gemini and HuggingFace providers. Please provide the correct implementation or remove them if they are not supported.
142 | * [ ] The `agent_system.py` module contains a `FIXME` note regarding the use of a try-catch context manager. Please review and implement the intended error handling.
143 | * [ ] Add TypeScript testing guidelines (if a TypeScript frontend is planned for the future).
144 | 


--------------------------------------------------------------------------------
/CHANGELOG.md:
--------------------------------------------------------------------------------
 1 | # Changelog
 2 | 
 3 | All notable changes to this project will be documented in this file.
 4 | 
 5 | The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
 6 | and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 7 | 
 8 | ## Guiding Principles
 9 | 
10 | - Changelogs are for humans, not machines.
11 | - There should be an entry for every single version.
12 | - The same types of changes should be grouped.
13 | - Versions and sections should be linkable.
14 | - The latest version comes first.
15 | - The release date of each version is displayed.
16 | - Mention whether you follow Semantic Versioning.
17 | 
18 | ## Types of changes
19 | 
20 | - `Added` for new features.
21 | - `Changed` for changes in existing functionality.
22 | - `Deprecated` for soon-to-be removed features.
23 | - `Removed` for now removed features.
24 | - `Fixed` for any bug fixes.
25 | - `Security` in case of vulnerabilities.
26 | 
27 | ## [Unreleased]
28 | 
29 | ## [0.0.1] - 2025-07-07
30 | 
31 | ### Added
32 | 
33 | - Initial template containing templates for PRP
34 | 


--------------------------------------------------------------------------------
/CLAUDE.md:
--------------------------------------------------------------------------------
1 | @AGENTS.md


--------------------------------------------------------------------------------
/Makefile:
--------------------------------------------------------------------------------
  1 | # This Makefile automates the build, test, and clean processes for the project.
  2 | # It provides a convenient way to run common tasks using the 'make' command.
  3 | # Run `make help` to see all available recipes.
  4 | 
  5 | .SILENT:
  6 | .ONESHELL:
  7 | .PHONY: all setup_python_claude setup_dev setup_prod setup_claude_code prp_gen_claude prp_exe_claude ruff test_all check_types coverage_all output_unset_app_env_sh run_gui run_server run_client help
  8 | .DEFAULT_GOAL := help
  9 | 
 10 | 
 11 | ENV_FILE := .env
 12 | SRC_PATH := src
 13 | APP_PATH := $(SRC_PATH)
 14 | FEAT_DEF_PATH := /context/features
 15 | PRP_DEF_PATH := /context/PRPs
 16 | PRP_CLAUDE_GEN_CMD := generate-prp
 17 | PRP_CLAUDE_EXE_CMD := execute-prp
 18 | 
 19 | 
 20 | # MARK: setup
 21 | 
 22 | 
 23 | # construct the full paths and execute Claude Code commands
 24 | # TODO switch folder by function called ()
 25 | # TODO Claude Code non-interactive headless mode tee to CLI
 26 | define CLAUDE_PRP_RUNNER
 27 | 	echo "Starting Claude Code PRP runner ..."
 28 | 	dest_file=$(firstword $(strip $(1)))
 29 | 	dest_cmd=$(firstword $(strip $(2)))
 30 | 	if [ -z "${dest_file}" ]; then
 31 | 		echo "Error: ARGS for PRP filename is empty. Please provide a PRP filename."
 32 | 		exit 1
 33 | 	fi
 34 | 	case "${dest_cmd}" in
 35 | 		start)
 36 | 			dest_cmd=$(PRP_CLAUDE_GEN_CMD)
 37 | 			dest_path=$(FEAT_DEF_PATH);;
 38 |   		stop)
 39 | 			dest_cmd=$(PRP_CLAUDE_EXE_CMD)
 40 | 			dest_path=$(PRP_DEF_PATH);;
 41 | 		*)
 42 |     		echo "Unknown command: ${dest_cmd}. Exiting ..."
 43 |     		exit 1;;
 44 | 	esac
 45 | 	dest_cmd="/project:${dest_cmd} ${dest_path}/${dest_file}"
 46 | 	echo "Executing command '${dest_cmd}' ..."
 47 | 	claude -p "${dest_cmd}" 2>&1
 48 | 	claude -p "/cost" 2>&1
 49 | endef
 50 | 
 51 | 
 52 | setup_python_claude:  # Set up environment and install Claude Code CLI
 53 | 	$(MAKE) -s setup_dev
 54 | 	$(MAKE) -s export_env_file
 55 | 	$(MAKE) -s setup_claude_code
 56 | 
 57 | 
 58 | setup_dev:  ## Install uv and deps, Download and start Ollama 
 59 | 	echo "Setting up dev environment ..."
 60 | 	pip install uv -q
 61 | 	uv sync --all-groups
 62 | 
 63 | 
 64 | setup_prod:  ## Install uv and deps, Download and start Ollama 
 65 | 	echo "Setting up prod environment ..."
 66 | 	pip install uv -q
 67 | 	uv sync --frozen
 68 | 
 69 | 
 70 | setup_claude_code:  ## Setup Claude Code CLI, node.js and npm have to be present
 71 | 	echo "Setting up claude code ..."
 72 | 	npm install -g @anthropic-ai/claude-code
 73 | 	claude config set --global preferredNotifChannel terminal_bell
 74 | 	echo "npm version: $(npm --version)"
 75 | 	claude --version
 76 | 
 77 | 
 78 | export_env_file:  # Read ENV_FILE and export k=v to env
 79 | 	while IFS='=' read -r key value || [ -n "${key}" ]; do
 80 | 		case "${key}" in
 81 | 			''|\#*) continue ;;
 82 | 		esac
 83 | 		value=$(echo "${value}" | sed -e 's/^"//' -e 's/"$//')
 84 | 		export "${key}=${value}"
 85 | 	done < .env
 86 | 
 87 | 
 88 | output_unset_env_sh:  ## Unset app environment variables
 89 | 	uf="./unset_env.sh"
 90 | 	echo "Outputing '${uf}' ..."
 91 | 	printenv | awk -F= '/_API_KEY=/ {print "unset " $1}' > $uf
 92 | 
 93 | 
 94 | # MARK: context engineering
 95 | 
 96 | 
 97 | prp_gen_claude:  ## generates the PRP from the file passed in "ARGS=file"
 98 | 	$(call CLAUDE_PRP_RUNNER, $(ARGS), "generate")
 99 | 
100 | 
101 | prp_exe_claude:  ## executes the PRP from the file passed in "ARGS=file"
102 | 	$(call CLAUDE_PRP_RUNNER, $(ARGS), "execute")
103 | 
104 | 
105 | # MARK: code quality
106 | 
107 | 
108 | ruff:  ## Lint: Format and check with ruff
109 | 	uv run ruff format
110 | 	uv run ruff check --fix
111 | 
112 | 
113 | test_all:  ## Run all tests
114 | 	uv run pytest
115 | 
116 | 
117 | coverage_all:  ## Get test coverage
118 | 	uv run coverage run -m pytest || true
119 | 	uv run coverage report -m
120 | 
121 | 
122 | check_types:  ## Check for static typing errors
123 | 	uv run mypy $(APP_PATH)
124 | 
125 | 
126 | # MARK: run
127 | 
128 | 
129 | run_gui:  ## Launch Streamlit GUI
130 | 	uv run python -m src.main gui
131 | 
132 | 
133 | run_server:  ## Run MCP server
134 | 	uv run python -m src.main server
135 | 
136 | 
137 | run_client:  ## Run MCP client (requires TOOL and ARGS)
138 | 	uv run python -m src.main client $(ARGS)
139 | 
140 | 
141 | # MARK: help
142 | 
143 | 
144 | # TODO add stackoverflow source
145 | help:  ## Displays this message with available recipes
146 | 	echo "Usage: make [recipe]"
147 | 	echo "Recipes:"
148 | 	awk '/^[a-zA-Z0-9_-]+:.*?##/ {
149 | 		helpMessage = match($0, /## (.*)/)
150 | 		if (helpMessage) {
151 | 			recipe = $1
152 | 			sub(/:/, "", recipe)
153 | 			printf "  \033[36m%-20s\033[0m %s\n", recipe, substr($0, RSTART + 3, RLENGTH)
154 | 		}
155 | 	}' $(MAKEFILE_LIST)
156 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
 1 | # Context Engineering Template
 2 | 
 3 | This project aims to implement a template for context engineering with coding agents. As suggested by several resources, including [context-engineering-intro](https://github.com/coleam00/context-engineering-intro), [The rise of "context engineering"](https://blog.langchain.com/the-rise-of-context-engineering/), [Context Engineering](https://blog.langchain.com/context-engineering-for-agents/) and somewhat [He Built 40 Startups Using Just Prompts — Here’s His System](https://youtu.be/CIAu6WeckQ0).
 4 | 
 5 | [![License](https://img.shields.io/badge/license-GNUGPLv3-green.svg)](LICENSE)
 6 | ![Version](https://img.shields.io/badge/version-0.0.1-58f4c2)
 7 | [![CodeQL](https://github.com/qte77/context-engineering-template/actions/workflows/codeql.yaml/badge.svg)](https://github.com/qte77/context-engineering-template/actions/workflows/codeql.yaml)
 8 | [![CodeFactor](https://www.codefactor.io/repository/github/qte77/context-engineering-template/badge)](https://www.codefactor.io/repository/github/qte77/context-engineering-template)
 9 | [![ruff](https://github.com/qte77/context-engineering-template/actions/workflows/ruff.yaml/badge.svg)](https://github.com/qte77/context-engineering-template/actions/workflows/ruff.yaml)
10 | [![pytest](https://github.com/qte77/context-engineering-template/actions/workflows/pytest.yaml/badge.svg)](https://github.com/qte77/context-engineering-template/actions/workflows/pytest.yaml)
11 | [![Link Checker](https://github.com/qte77/context-engineering-template/actions/workflows/links-fail-fast.yaml/badge.svg)](https://github.com/qte77/context-engineering-template/actions/workflows/links-fail-fast.yaml)
12 | [![Deploy Docs](https://github.com/qte77/context-engineering-template/actions/workflows/generate-deploy-mkdocs-ghpages.yaml/badge.svg)](https://github.com/qte77/context-engineering-template/actions/workflows/generate-deploy-mkdocs-ghpages.yaml)
13 | 
14 | **DevEx** [![vscode.dev](https://img.shields.io/static/v1?logo=visualstudiocode&label=&message=vscode.dev&labelColor=2c2c32&color=007acc&logoColor=007acc)](https://vscode.dev/github/qte77/context-engineering-template)
15 | [![Codespace Python Claude](https://img.shields.io/static/v1?logo=visualstudiocode&label=&message=Codespace%20Dev&labelColor=2c2c32&color=007acc&logoColor=007acc)](https://github.com/codespaces/new?repo=qte77/context-engineering-template&devcontainer_path=.devcontainer/setup_python_claude/devcontainer.json)
16 | [![TalkToGithub](https://img.shields.io/badge/TalkToGithub-7a83ff.svg)](https://talktogithub.com/qte77/context-engineering-template)
17 | [![llms.txt (UitHub)](https://img.shields.io/badge/llms.txt-uithub-800080.svg)](https://github.com/qte77/context-engineering-template)
18 | [![llms.txt (GitToDoc)](https://img.shields.io/badge/llms.txt-GitToDoc-fe4a60.svg)](https://gittodoc.com/qte77/context-engineering-template)
19 | 
20 | ## Status
21 | 
22 | (DRAFT) (WIP) ----> Not fully implemented yet
23 | 
24 | For version history have a look at the [CHANGELOG](CHANGELOG.md).
25 | 
26 | ## Purpose
27 | 
28 | Let the Coding Agent do the heavy lifting. Build code base from top to bottom: Define Business Requirements (BRD) and afterwards features to be implemented. The goal could be to to implement some kind of guided top-down BDD: behavior > tests > implementation.
29 | 
30 | ## Features
31 | 
32 | - Runs tests, linting and type checks: only
33 | 
34 | <details>
35 |   <summary>Show Sequence Diagram</summary>
36 |   <a href="assets/images/sequence_diagram.png">
37 |     <img src="assets/images/sequence_diagram.png#gh-light-mode-only" alt="Sequence Diagram" title="Sequence Diagram" width="111%" />
38 |   </a>
39 |   <a href="assets/images/sequence_diagram.png">
40 |     <img src="assets/images/sequence_diagram.png#gh-dark-mode-only" alt="Sequence Diagram" title="Sequence Diagram" width="111%" />
41 |   </a>
42 | </details>
43 | 
44 | ## Setup
45 | 
46 | 1. `make setup_python_claude`
47 | 2. If .env to be used: `make export_env_file`
48 | 
49 | ## Usage
50 | 
51 | 1. Update [Agents.md](AGENTS.md) to your needs.
52 | 2. Describe desired feature in `/context/features/feature_XXX.md`, like shown in [feature_base.md](/context/templates/feature_base.md).
53 | 3. Place optional examples into [/context/examples](/context/examples).
54 | 4. Let the Product Requirements Prompt (PRP) be generated:
55 |    - In Claude Code CLI: `/generate-prp feature_XXX.md`
56 |    - or: `make prp_gen_claude "ARGS=feature_XXX.md"`
57 | 5. Let the feature be implemented based on the PRP:
58 |    - In Claude Code CLI: `/execute-prp feature_XXX.md`
59 |    - or: `make prp_exe_claude "ARGS=feature_XXX.md"`
60 | 
61 | ### Configuration
62 | 
63 | - General system behavior: `AGENTS.md`, redirected from `CLAUDE.md`
64 | - Claude settings: `.claude/settings.local.json`
65 | - CLaude commands: `.claude/commands`
66 | - Feature template: `context/templates/feature_base.md`
67 | - PRP template: `context/templates/prp_base.md`
68 | 
69 | ### Environment
70 | 
71 | [.env.example](.env.example) contains examples for usage of API keys and variables.
72 | 
73 | ```text
74 | ANTHROPIC_API_KEY="sk-abc-xyz"
75 | GEMINI_API_KEY="xyz"
76 | GITHUB_API_KEY="ghp_xyz"
77 | ...
78 | ```
79 | 
80 | ## TODO
81 | 
82 | - Implement business process as discussed in [He Built 40 Startups Using Just Prompts — Here’s His System](https://youtu.be/CIAu6WeckQ0)
83 | - Refine `AGENTS.md` to let the agent not do bulk but incremental changes, also implement tests first, then code and iterate until functional (red > green > blue).
84 | 


--------------------------------------------------------------------------------
/assets/images/example_execute_feature_mcp_server_PRP_update_pyproject.PNG:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/assets/images/example_execute_feature_mcp_server_PRP_update_pyproject.PNG


--------------------------------------------------------------------------------
/assets/images/example_execute_feature_mcp_server_PRP_update_pyproject_diff.PNG:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/assets/images/example_execute_feature_mcp_server_PRP_update_pyproject_diff.PNG


--------------------------------------------------------------------------------
/assets/images/example_execute_feature_mcp_server_created.PNG:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/assets/images/example_execute_feature_mcp_server_created.PNG


--------------------------------------------------------------------------------
/assets/images/example_generate_feature_mcp_server_PRP.PNG:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/assets/images/example_generate_feature_mcp_server_PRP.PNG


--------------------------------------------------------------------------------
/assets/images/sequence_diagram.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/assets/images/sequence_diagram.png


--------------------------------------------------------------------------------
/context/examples/client_get_date_input.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Simple client input format for get_date tool",
 3 |   "cli_command": "python -m src.main client --server src/mcp_server/server.py get_date --timezone UTC",
 4 |   "expected_input": {
 5 |     "tool": "get_date",
 6 |     "arguments": {
 7 |       "timezone": "UTC"
 8 |     }
 9 |   },
10 |   "expected_output_format": {
11 |     "success": true,
12 |     "tool_name": "get_date",
13 |     "result": {
14 |       "content": [
15 |         {
16 |           "type": "text",
17 |           "text": "🕐 **Current Date & Time**\n📅 Date: **2025-07-07** (Monday)\n⏰ Time: **14:30:25**\n🌍 Timezone: **UTC**\n📋 ISO 8601: `2025-07-07T14:30:25+00:00`\n🔢 Unix Timestamp: `1720360225`"
18 |         }
19 |       ]
20 |     }
21 |   },
22 |   "examples": [
23 |     {
24 |       "timezone": "America/New_York",
25 |       "description": "Get Eastern Time"
26 |     },
27 |     {
28 |       "timezone": "Europe/London",
29 |       "description": "Get London time"
30 |     },
31 |     {
32 |       "timezone": "Asia/Tokyo",
33 |       "description": "Get Tokyo time"
34 |     },
35 |     {
36 |       "timezone": "pst",
37 |       "description": "Get Pacific Time using alias"
38 |     }
39 |   ]
40 | }
41 | 


--------------------------------------------------------------------------------
/context/examples/client_get_weather_input.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Simple client input format for get_weather tool",
 3 |   "cli_command": "python -m src.main client --server src/mcp_server/server.py get_weather --location 'San Francisco'",
 4 |   "expected_input": {
 5 |     "tool": "get_weather",
 6 |     "arguments": {
 7 |       "location": "San Francisco"
 8 |     }
 9 |   },
10 |   "expected_output_format": {
11 |     "success": true,
12 |     "tool_name": "get_weather",
13 |     "result": {
14 |       "content": [
15 |         {
16 |           "type": "text",
17 |           "text": "🌤️ **Weather for San Francisco**\n🌡️ Temperature: **18.5°C**\n☁️ Condition: **Partly cloudy**\n💨 Wind Speed: **12.3 km/h**\n💧 Humidity: **65%**\n🕐 Updated: 2025-07-07 14:30 UTC"
18 |         }
19 |       ]
20 |     }
21 |   },
22 |   "examples": [
23 |     {
24 |       "location": "London",
25 |       "description": "Get weather for London"
26 |     },
27 |     {
28 |       "location": "New York",
29 |       "description": "Get weather for New York"
30 |     },
31 |     {
32 |       "location": "37.7749,-122.4194",
33 |       "description": "Get weather using coordinates"
34 |     }
35 |   ]
36 | }
37 | 


--------------------------------------------------------------------------------
/context/examples/client_invalid_tool.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Error handling example for invalid tool",
 3 |   "cli_command": "python -m src.main client --server src/mcp_server/server.py invalid_tool --arg value",
 4 |   "expected_input": {
 5 |     "tool": "invalid_tool",
 6 |     "arguments": {
 7 |       "arg": "value"
 8 |     }
 9 |   },
10 |   "expected_output_format": {
11 |     "success": false,
12 |     "tool_name": "invalid_tool",
13 |     "error": "Tool 'invalid_tool' not available. Available tools: ['roll_dice', 'get_weather', 'get_date']",
14 |     "arguments": {
15 |       "arg": "value"
16 |     }
17 |   },
18 |   "error_scenarios": [
19 |     {
20 |       "scenario": "Tool not available",
21 |       "tool": "nonexistent_tool",
22 |       "expected_error": "Tool 'nonexistent_tool' not available"
23 |     },
24 |     {
25 |       "scenario": "Server not running",
26 |       "server_path": "./nonexistent_server.py",
27 |       "expected_error": "Server script not found"
28 |     },
29 |     {
30 |       "scenario": "Invalid server path",
31 |       "server_path": "/dev/null",
32 |       "expected_error": "Failed to connect to server"
33 |     },
34 |     {
35 |       "scenario": "Connection timeout",
36 |       "timeout": 1,
37 |       "expected_error": "Connection timeout"
38 |     }
39 |   ]
40 | }
41 | 


--------------------------------------------------------------------------------
/context/examples/client_roll_dice_input.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Simple client input format for roll_dice tool",
 3 |   "cli_command": "python -m src.main client --server src/mcp_server/server.py roll_dice --notation 2d6",
 4 |   "expected_input": {
 5 |     "tool": "roll_dice",
 6 |     "arguments": {
 7 |       "notation": "2d6"
 8 |     }
 9 |   },
10 |   "expected_output_format": {
11 |     "success": true,
12 |     "tool_name": "roll_dice",
13 |     "result": {
14 |       "content": [
15 |         {
16 |           "type": "text",
17 |           "text": "🎲 Rolled 2d6: [3, 5] = **8**"
18 |         }
19 |       ]
20 |     }
21 |   },
22 |   "examples": [
23 |     {
24 |       "notation": "1d20",
25 |       "description": "Roll a 20-sided die"
26 |     },
27 |     {
28 |       "notation": "3d6",
29 |       "description": "Roll three 6-sided dice"
30 |     },
31 |     {
32 |       "notation": "2d10",
33 |       "description": "Roll two 10-sided dice"
34 |     }
35 |   ]
36 | }
37 | 


--------------------------------------------------------------------------------
/context/examples/features/feature_1_mcp_server.md:
--------------------------------------------------------------------------------
 1 | # Feature description for: MCP Server with tools
 2 | 
 3 | ## FEATURE
 4 | 
 5 | Implement an **MCP (Message Control Protocol) Server** in Python that exposes three callable tools via structured messages. The server should receive well-formed MCP messages and dispatch tool invocations accordingly. The three tools to be exposed are:
 6 | 
 7 | 1. **Roll Dice**: Accepts a format like `2d6` or `1d20` and returns the rolled values and total.
 8 | 2. **Get Weather**: Accepts a city name or coordinates and returns the current weather conditions using a public weather API.
 9 | 3. **Get Date**: Returns the current date and time in ISO 8601 format or based on a requested timezone.
10 | 
11 | The server should be modular, testable, and extensible for future tools. Logging, error handling, and message validation should be considered first-class concerns.
12 | 
13 | ## EXAMPLES
14 | 
15 | Located in `/context/examples`:
16 | 
17 | * `roll_dice_example.json`: Demonstrates sending `{"tool": "roll_dice", "args": {"notation": "3d6"}}` and receiving `{"result": {"values": [4,2,6], "total": 12}}`.
18 | * `get_weather_example.json`: Sends `{"tool": "get_weather", "args": {"location": "San Francisco"}}` and expects weather data such as temperature, condition, and wind speed.
19 | * `get_date_example.json`: Sends `{"tool": "get_date", "args": {"timezone": "UTC"}}` and receives `{"result": "2025-07-06T16:22:00Z"}`.
20 | 
21 | These examples cover correct usage and malformed inputs to validate tool response and error handling.
22 | 
23 | ## DOCUMENTATION
24 | 
25 | * [Open-Meteo API](https://open-meteo.com/en/docs): For retrieving weather information.
26 | * [Python `datetime` module](https://docs.python.org/3/library/datetime.html): For implementing date and time tool.
27 | * [random module (Python)](https://docs.python.org/3/library/random.html): For rolling dice.
28 | * \[MCP Protocol Overview (proprietary/internal if applicable)] or general protocol documentation, if using a specific spec.
29 | 
30 | Additional context from [context-engineering-intro](https://github.com/qte77/context-engineering-template) will inform message structure and processing strategy.
31 | 
32 | ## OTHER CONSIDERATIONS
33 | 
34 | * **Tool routing logic** should be clearly separated to allow clean expansion.
35 | * **Input validation** is critical: especially for `roll_dice`, invalid formats (e.g., `3x5`, `0d6`, `d10`) must return informative errors.
36 | * **Weather API failures or rate limits** should be gracefully handled with fallback messages.
37 | * **Timezone parsing** for `get_date` should use `pytz` or `zoneinfo`, and clearly inform users when timezones are unsupported.
38 | * **Security note**: Weather and date APIs should not expose sensitive request metadata or leak internal server details in errors.
39 | * AI coding assistants often:
40 | 
41 |   * Miss edge case handling (e.g., zero dice, negative sides)
42 |   * Forget to structure results consistently across tools
43 |   * Fail to modularize tool logic, making future expansion difficult
44 | 


--------------------------------------------------------------------------------
/context/examples/features/feature_2_mcp_client.md:
--------------------------------------------------------------------------------
 1 | # Feature description for: MCP Client for Tool Invocation
 2 | 
 3 | ## FEATURE
 4 | 
 5 | Implement a **Python-based MCP Client** capable of sending structured requests to an MCP Server and handling the corresponding responses. The client should:
 6 | 
 7 | * Connect to the MCP server over a socket, HTTP, or another configured protocol.
 8 | * Serialize requests into the expected MCP message format (e.g., JSON or line-based protocol).
 9 | * Provide a command-line interface (CLI) and/or programmatic interface for interacting with the following tools:
10 | 
11 |   1. **Roll Dice** (`roll_dice`) – accepts dice notation like `2d6`, `1d20`.
12 |   2. **Get Weather** (`get_weather`) – accepts a location name or coordinates.
13 |   3. **Get Date** (`get_date`) – optionally accepts a timezone.
14 | 
15 | The client should also handle connection errors, invalid tool responses, and retry logic gracefully.
16 | 
17 | ## EXAMPLES
18 | 
19 | Located in `/context/examples`:
20 | 
21 | * `client_roll_dice_input.json`: `{ "tool": "roll_dice", "args": { "notation": "2d6" } }`
22 | * `client_get_weather_input.json`: `{ "tool": "get_weather", "args": { "location": "Berlin" } }`
23 | * `client_get_date_input.json`: `{ "tool": "get_date", "args": { "timezone": "UTC" } }`
24 | * `client_invalid_tool.json`: `{ "tool": "fly_to_mars", "args": {} }` → Should trigger a meaningful error from the server
25 | 
26 | These example requests and expected responses can be used for local testing and automated integration checks.
27 | 
28 | ## DOCUMENTATION
29 | 
30 | * [Python `socket` module](https://docs.python.org/3/library/socket.html) or [requests](https://docs.python.org/3/library/urllib.request.html) depending on transport.
31 | * [JSON module](https://docs.python.org/3/library/json.html) for message formatting.
32 | * [argparse](https://docs.python.org/3/library/argparse.html) for implementing a simple CLI wrapper.
33 | * Reference the MCP Server protocol spec or internal documentation (e.g. *MCP Protocol Overview* if proprietary).
34 | * [context-engineering-template](https://github.com/qte/context-engineering-template) for usage conventions.
35 | 
36 | ## OTHER CONSIDERATIONS
37 | 
38 | * Client must validate outgoing messages before sending to avoid malformed requests.
39 | * Handle connection errors, timeouts, and retries in a user-friendly manner.
40 | * The response handler should check for required fields (`result`, `error`, etc.) to avoid crashes on malformed server responses.
41 | * Consider pluggability of tools so future expansions can be supported with minimal refactoring.
42 | * AI assistants often:
43 | 
44 |   * Miss error handling around partial or no server responses.
45 |   * Forget to properly close socket connections or handle timeouts.
46 |   * Write overly rigid request builders, making CLI usage frustrating.
47 | 


--------------------------------------------------------------------------------
/context/examples/features/feature_3_streamlit_gui.md:
--------------------------------------------------------------------------------
 1 | # Feature description for: Streamlit GUI for MCP Server-Client Interaction Showcase
 2 | 
 3 | ## FEATURE
 4 | 
 5 | Develop a **Streamlit-based graphical user interface (GUI)** to demonstrate and interactively showcase the communication and integration between the MCP Server and MCP Client. The GUI should allow users to:
 6 | 
 7 | * Select and invoke any of the three available tools (`roll_dice`, `get_weather`, `get_date`) via intuitive form inputs.
 8 | * Enter tool-specific parameters such as dice notation, location, or timezone.
 9 | * Display real-time request payloads sent by the client and the corresponding responses received from the server.
10 | * Handle and display error messages gracefully.
11 | * Log interaction history for the current session, allowing users to review previous commands and results.
12 | * Provide clear visual feedback about the status of the connection and request execution.
13 | 
14 | This GUI acts as both a testing ground and demonstration interface, useful for users unfamiliar with command-line tools or raw protocol messages.
15 | 
16 | ## EXAMPLES
17 | 
18 | Located in `/context/examples`:
19 | 
20 | * `streamlit_roll_dice_interaction.json`: Example input/output pairs demonstrating a dice roll session in the GUI.
21 | * `streamlit_get_weather_interaction.json`: Demonstrates user inputs for location and the displayed weather response.
22 | * `streamlit_get_date_interaction.json`: Shows date/time requests with optional timezone selection.
23 | * `streamlit_error_handling.json`: Examples of how the GUI displays server-side validation errors or connection issues.
24 | 
25 | These examples serve as test cases for GUI input validation and response rendering.
26 | 
27 | ## DOCUMENTATION
28 | 
29 | * [Streamlit Documentation](https://docs.streamlit.io/) for building interactive Python apps.
30 | * \[MCP Server and Client Protocol Specs] (internal/proprietary or from context-engineering-intro).
31 | * Python libraries for HTTP or socket communication used by the client.
32 | * UI/UX design best practices for interactive demos.
33 | * [context-engineering-intro](https://github.com/coleam00/context-engineering-intro) for project conventions.
34 | 
35 | ## OTHER CONSIDERATIONS
36 | 
37 | * Ensure asynchronous or non-blocking communication so the UI remains responsive during server interactions.
38 | * Validate inputs in the GUI before sending to the client to minimize server errors.
39 | * Provide helpful tooltips or inline help to explain tool parameters to users unfamiliar with dice notation or timezone formats.
40 | * Consider session state management in Streamlit to maintain history and status.
41 | * AI coding assistants often overlook proper error propagation to the UI and user-friendly messaging.
42 | * Security considerations: if exposing any sensitive endpoints or API keys, avoid hardcoding secrets in the GUI code.
43 | * Design with extensibility in mind to add new tools or more complex workflows easily.
44 | 


--------------------------------------------------------------------------------
/context/examples/get_date_example.json:
--------------------------------------------------------------------------------
  1 | {
  2 |   "description": "Example request and response for the get_date tool",
  3 |   "request": {
  4 |     "jsonrpc": "2.0",
  5 |     "method": "tools/call",
  6 |     "params": {
  7 |       "name": "get_date",
  8 |       "arguments": {
  9 |         "timezone": "UTC"
 10 |       }
 11 |     },
 12 |     "id": 3
 13 |   },
 14 |   "response": {
 15 |     "jsonrpc": "2.0",
 16 |     "id": 3,
 17 |     "result": {
 18 |       "content": [
 19 |         {
 20 |           "type": "text",
 21 |           "text": "🕐 **Current Date & Time**\n📅 Date: **2025-07-07** (Monday)\n⏰ Time: **14:30:25**\n🌍 Timezone: **UTC**\n📋 ISO 8601: `2025-07-07T14:30:25+00:00`\n🔢 Unix Timestamp: `1720360225`"
 22 |         }
 23 |       ],
 24 |       "isError": false
 25 |     }
 26 |   },
 27 |   "examples": {
 28 |     "valid_requests": [
 29 |       {
 30 |         "timezone": "UTC",
 31 |         "description": "Coordinated Universal Time"
 32 |       },
 33 |       {
 34 |         "timezone": "America/New_York",
 35 |         "description": "Eastern Time"
 36 |       },
 37 |       {
 38 |         "timezone": "America/Los_Angeles",
 39 |         "description": "Pacific Time"
 40 |       },
 41 |       {
 42 |         "timezone": "Europe/London",
 43 |         "description": "British Time"
 44 |       },
 45 |       {
 46 |         "timezone": "Asia/Tokyo",
 47 |         "description": "Japan Standard Time"
 48 |       },
 49 |       {
 50 |         "timezone": "est",
 51 |         "description": "Eastern Time alias"
 52 |       },
 53 |       {
 54 |         "timezone": "pst",
 55 |         "description": "Pacific Time alias"
 56 |       }
 57 |     ],
 58 |     "invalid_requests": [
 59 |       {
 60 |         "timezone": "Invalid/Timezone",
 61 |         "error": "Invalid timezone: 'Invalid/Timezone'. Common timezones: UTC, America/New_York, America/Los_Angeles, America/Chicago, Europe/London, Europe/Paris, Asia/Tokyo, Australia/Sydney. Aliases: utc, gmt, est, pst, cst, mst, edt, pdt, cdt, mdt, bst, cet, jst, aest. Use IANA timezone names (e.g., 'America/New_York') or aliases."
 62 |       },
 63 |       {
 64 |         "timezone": "",
 65 |         "error": "Timezone cannot be empty"
 66 |       }
 67 |     ]
 68 |   },
 69 |   "supported_timezones": {
 70 |     "aliases": {
 71 |       "utc": "UTC",
 72 |       "gmt": "UTC", 
 73 |       "est": "America/New_York",
 74 |       "pst": "America/Los_Angeles",
 75 |       "cst": "America/Chicago",
 76 |       "mst": "America/Denver",
 77 |       "edt": "America/New_York",
 78 |       "pdt": "America/Los_Angeles",
 79 |       "cdt": "America/Chicago",
 80 |       "mdt": "America/Denver",
 81 |       "bst": "Europe/London",
 82 |       "cet": "Europe/Paris",
 83 |       "jst": "Asia/Tokyo",
 84 |       "aest": "Australia/Sydney"
 85 |     },
 86 |     "common_iana_zones": [
 87 |       "UTC",
 88 |       "America/New_York",
 89 |       "America/Los_Angeles", 
 90 |       "America/Chicago",
 91 |       "America/Denver",
 92 |       "Europe/London",
 93 |       "Europe/Paris",
 94 |       "Europe/Berlin",
 95 |       "Asia/Tokyo",
 96 |       "Asia/Shanghai",
 97 |       "Australia/Sydney"
 98 |     ]
 99 |   }
100 | }


--------------------------------------------------------------------------------
/context/examples/get_weather_example.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Example request and response for the get_weather tool",
 3 |   "request": {
 4 |     "jsonrpc": "2.0",
 5 |     "method": "tools/call",
 6 |     "params": {
 7 |       "name": "get_weather",
 8 |       "arguments": {
 9 |         "location": "San Francisco"
10 |       }
11 |     },
12 |     "id": 2
13 |   },
14 |   "response": {
15 |     "jsonrpc": "2.0",
16 |     "id": 2,
17 |     "result": {
18 |       "content": [
19 |         {
20 |           "type": "text",
21 |           "text": "🌤️ **Weather for San Francisco**\n🌡️ Temperature: **18.5°C**\n☁️ Condition: **Partly cloudy**\n💨 Wind Speed: **12.3 km/h**\n💧 Humidity: **65%**\n🕐 Updated: 2025-07-07 14:30 UTC"
22 |         }
23 |       ],
24 |       "isError": false
25 |     }
26 |   },
27 |   "examples": {
28 |     "valid_requests": [
29 |       {
30 |         "location": "London",
31 |         "description": "Weather for London city"
32 |       },
33 |       {
34 |         "location": "New York",
35 |         "description": "Weather for New York city"
36 |       },
37 |       {
38 |         "location": "37.7749,-122.4194",
39 |         "description": "Weather using coordinates (San Francisco)"
40 |       },
41 |       {
42 |         "location": "Tokyo",
43 |         "description": "Weather for Tokyo city"
44 |       }
45 |     ],
46 |     "invalid_requests": [
47 |       {
48 |         "location": "Unknown City",
49 |         "error": "Unknown location: 'Unknown City'. Please use coordinates (lat,lon) or one of: berlin, beijing, cairo, chicago, lagos, london, los angeles, madrid, miami, moscow, mumbai, new york, paris, rome, san francisco, seattle, sydney, tokyo, toronto, vancouver"
50 |       },
51 |       {
52 |         "location": "",
53 |         "error": "Location cannot be empty"
54 |       },
55 |       {
56 |         "location": "999,999",
57 |         "error": "Unknown location: '999,999'. Please use coordinates (lat,lon) or one of: [city list]"
58 |       }
59 |     ]
60 |   },
61 |   "supported_cities": [
62 |     "San Francisco",
63 |     "New York", 
64 |     "London",
65 |     "Paris",
66 |     "Tokyo",
67 |     "Sydney",
68 |     "Los Angeles",
69 |     "Chicago",
70 |     "Miami",
71 |     "Seattle",
72 |     "Vancouver",
73 |     "Toronto",
74 |     "Berlin",
75 |     "Rome",
76 |     "Madrid",
77 |     "Moscow",
78 |     "Beijing",
79 |     "Mumbai",
80 |     "Cairo",
81 |     "Lagos"
82 |   ]
83 | }


--------------------------------------------------------------------------------
/context/examples/roll_dice_example.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "description": "Example request and response for the roll_dice tool",
 3 |   "request": {
 4 |     "jsonrpc": "2.0",
 5 |     "method": "tools/call",
 6 |     "params": {
 7 |       "name": "roll_dice",
 8 |       "arguments": {
 9 |         "notation": "3d6"
10 |       }
11 |     },
12 |     "id": 1
13 |   },
14 |   "response": {
15 |     "jsonrpc": "2.0",
16 |     "id": 1,
17 |     "result": {
18 |       "content": [
19 |         {
20 |           "type": "text",
21 |           "text": "🎲 Rolled 3d6: [4, 2, 6] = **12**"
22 |         }
23 |       ],
24 |       "isError": false
25 |     }
26 |   },
27 |   "examples": {
28 |     "valid_requests": [
29 |       {
30 |         "notation": "1d20",
31 |         "description": "Single twenty-sided die"
32 |       },
33 |       {
34 |         "notation": "2d6",
35 |         "description": "Two six-sided dice"
36 |       },
37 |       {
38 |         "notation": "4d10",
39 |         "description": "Four ten-sided dice"
40 |       }
41 |     ],
42 |     "invalid_requests": [
43 |       {
44 |         "notation": "d6",
45 |         "error": "Invalid dice notation: 'd6'. Expected format: 'XdY' (e.g., '2d6', '1d20')"
46 |       },
47 |       {
48 |         "notation": "0d6",
49 |         "error": "Dice count must be greater than 0"
50 |       },
51 |       {
52 |         "notation": "101d6",
53 |         "error": "Dice count must not exceed 100"
54 |       },
55 |       {
56 |         "notation": "1d0",
57 |         "error": "Number of sides must be greater than 0"
58 |       },
59 |       {
60 |         "notation": "abc",
61 |         "error": "Invalid dice notation: 'abc'. Expected format: 'XdY' (e.g., '2d6', '1d20')"
62 |       }
63 |     ]
64 |   }
65 | }


--------------------------------------------------------------------------------
/context/examples/streamlit_error_handling.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "interaction_type": "streamlit_gui",
 3 |   "tool_name": "roll_dice",
 4 |   "timestamp": "2024-01-15T10:36:00Z",
 5 |   "request": {
 6 |     "method": "tool_invocation",
 7 |     "parameters": {
 8 |       "tool": "roll_dice",
 9 |       "arguments": {
10 |         "notation": "invalid_dice"
11 |       }
12 |     }
13 |   },
14 |   "response": {
15 |     "success": false,
16 |     "result": null,
17 |     "error": "Invalid dice notation format: invalid_dice",
18 |     "tool_name": "roll_dice",
19 |     "arguments": {
20 |       "notation": "invalid_dice"
21 |     }
22 |   },
23 |   "execution_time": 0.05,
24 |   "gui_state": {
25 |     "connected": true,
26 |     "server_path": "src/mcp_server/server.py",
27 |     "available_tools": ["roll_dice", "get_weather", "get_date"]
28 |   },
29 |   "error_details": {
30 |     "validation_error": "Dice notation must follow pattern: NdN (e.g., 2d6, 1d20)",
31 |     "user_input": "invalid_dice",
32 |     "suggested_corrections": ["2d6", "1d20", "3d10"]
33 |   }
34 | }


--------------------------------------------------------------------------------
/context/examples/streamlit_get_date_interaction.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "interaction_type": "streamlit_gui",
 3 |   "tool_name": "get_date",
 4 |   "timestamp": "2024-01-15T10:34:00Z",
 5 |   "request": {
 6 |     "method": "tool_invocation",
 7 |     "parameters": {
 8 |       "tool": "get_date",
 9 |       "arguments": {
10 |         "timezone": "America/New_York"
11 |       }
12 |     }
13 |   },
14 |   "response": {
15 |     "success": true,
16 |     "result": {
17 |       "datetime": "2024-01-15T05:34:15-05:00",
18 |       "timezone": "America/New_York",
19 |       "formatted": "Monday, January 15, 2024 at 5:34:15 AM EST",
20 |       "unix_timestamp": 1705313655
21 |     },
22 |     "tool_name": "get_date",
23 |     "arguments": {
24 |       "timezone": "America/New_York"
25 |     }
26 |   },
27 |   "execution_time": 0.12,
28 |   "gui_state": {
29 |     "connected": true,
30 |     "server_path": "src/mcp_server/server.py",
31 |     "available_tools": ["roll_dice", "get_weather", "get_date"]
32 |   }
33 | }


--------------------------------------------------------------------------------
/context/examples/streamlit_get_weather_interaction.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "interaction_type": "streamlit_gui",
 3 |   "tool_name": "get_weather",
 4 |   "timestamp": "2024-01-15T10:32:00Z",
 5 |   "request": {
 6 |     "method": "tool_invocation",
 7 |     "parameters": {
 8 |       "tool": "get_weather",
 9 |       "arguments": {
10 |         "location": "San Francisco"
11 |       }
12 |     }
13 |   },
14 |   "response": {
15 |     "success": true,
16 |     "result": {
17 |       "location": "San Francisco, CA",
18 |       "temperature": "18°C",
19 |       "condition": "Partly cloudy",
20 |       "humidity": "65%",
21 |       "wind": "12 mph NW"
22 |     },
23 |     "tool_name": "get_weather",
24 |     "arguments": {
25 |       "location": "San Francisco"
26 |     }
27 |   },
28 |   "execution_time": 0.45,
29 |   "gui_state": {
30 |     "connected": true,
31 |     "server_path": "src/mcp_server/server.py",
32 |     "available_tools": ["roll_dice", "get_weather", "get_date"]
33 |   }
34 | }


--------------------------------------------------------------------------------
/context/examples/streamlit_roll_dice_interaction.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "interaction_type": "streamlit_gui",
 3 |   "tool_name": "roll_dice",
 4 |   "timestamp": "2024-01-15T10:30:00Z",
 5 |   "request": {
 6 |     "method": "tool_invocation",
 7 |     "parameters": {
 8 |       "tool": "roll_dice",
 9 |       "arguments": {
10 |         "notation": "2d6"
11 |       }
12 |     }
13 |   },
14 |   "response": {
15 |     "success": true,
16 |     "result": {
17 |       "values": [3, 5],
18 |       "total": 8,
19 |       "notation": "2d6"
20 |     },
21 |     "tool_name": "roll_dice",
22 |     "arguments": {
23 |       "notation": "2d6"
24 |     }
25 |   },
26 |   "execution_time": 0.15,
27 |   "gui_state": {
28 |     "connected": true,
29 |     "server_path": "src/mcp_server/server.py",
30 |     "available_tools": ["roll_dice", "get_weather", "get_date"]
31 |   }
32 | }


--------------------------------------------------------------------------------
/context/templates/feature_base.md:
--------------------------------------------------------------------------------
 1 | # Feature description for: [ Initial template for new features ]
 2 | 
 3 | ## FEATURE
 4 | 
 5 | [Insert your feature here]
 6 | 
 7 | ## EXAMPLES
 8 | 
 9 | [Provide and explain examples that you have in the `/context/examples` folder]
10 | 
11 | ## DOCUMENTATION
12 | 
13 | [List out any documentation (web pages, sources for an MCP server like Crawl4AI RAG, etc.) that will need to be referenced during development]
14 | 
15 | ## OTHER CONSIDERATIONS
16 | 
17 | [Any other considerations or specific requirements - great place to include gotchas that you see AI coding assistants miss with your projects a lot]
18 | 


--------------------------------------------------------------------------------
/context/templates/prp_base.md:
--------------------------------------------------------------------------------
  1 | # "Base PRP Template v2 - Context-Rich with Validation Loops"
  2 | 
  3 | ## Purpose
  4 | 
  5 | Product Requirements Prompt (PRP) Template optimized for AI agents to implement features with sufficient context and self-validation capabilities to achieve working code through iterative refinement.
  6 | 
  7 | ## Core Principles
  8 | 
  9 | 1. **Context is King**: Include ALL necessary documentation, examples, and caveats
 10 | 2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
 11 | 3. **Information Dense**: Use keywords and patterns from the codebase
 12 | 4. **Progressive Success**: Start simple, validate, then enhance
 13 | 5. **Global rules**: Be sure to follow all rules in CLAUDE.md
 14 | 
 15 | ---
 16 | 
 17 | ## Goal
 18 | 
 19 | [What needs to be built - be specific about the end state and desires]
 20 | 
 21 | ## Why
 22 | 
 23 | - [Business value and user impact]
 24 | - [Integration with existing features]
 25 | - [Problems this solves and for whom]
 26 | 
 27 | ## What
 28 | 
 29 | [User-visible behavior and technical requirements]
 30 | 
 31 | ### Success Criteria
 32 | 
 33 | - [ ] [Specific measurable outcomes]
 34 | 
 35 | ## All Needed Context
 36 | 
 37 | ### Documentation & References (list all context needed to implement the feature)
 38 | 
 39 | ```yaml
 40 | # MUST READ - Include these in your context window
 41 | - url: [Official API docs URL]
 42 |   why: [Specific sections/methods you'll need]
 43 |   
 44 | - file: [path/to/example.py]
 45 |   why: [Pattern to follow, gotchas to avoid]
 46 |   
 47 | - doc: [Library documentation URL] 
 48 |   section: [Specific section about common pitfalls]
 49 |   critical: [Key insight that prevents common errors]
 50 | 
 51 | - docfile: [PRPs/ai_docs/file.md]
 52 |   why: [docs that the user has pasted in to the project]
 53 | ```
 54 | 
 55 | ### Current Codebase tree (run `tree` in the root of the project) to get an overview of the codebase
 56 | 
 57 | ```bash
 58 | 
 59 | ```
 60 | 
 61 | ### Desired Codebase tree with files to be added and responsibility of file
 62 | 
 63 | ```bash
 64 | 
 65 | ```
 66 | 
 67 | ### Known Gotchas of our codebase & Library Quirks
 68 | 
 69 | ```python
 70 | # CRITICAL: [Library name] requires [specific setup]
 71 | # Example: FastAPI requires async functions for endpoints
 72 | # Example: This ORM doesn't support batch inserts over 1000 records
 73 | # Example: We use pydantic v2 and  
 74 | ```
 75 | 
 76 | ## Implementation Blueprint
 77 | 
 78 | ### Data models and structure
 79 | 
 80 | Create the core data models, we ensure type safety and consistency.
 81 | 
 82 | ```python
 83 | Examples: 
 84 |  - orm models
 85 |  - pydantic models
 86 |  - pydantic schemas
 87 |  - pydantic validators
 88 | 
 89 | ```
 90 | 
 91 | ### list of tasks to be completed to fullfill the PRP in the order they should be completed
 92 | 
 93 | ```yaml
 94 | Task 1:
 95 | MODIFY src/existing_module.py:
 96 |   - FIND pattern: "class OldImplementation"
 97 |   - INJECT after line containing "def __init__"
 98 |   - PRESERVE existing method signatures
 99 | 
100 | CREATE src/new_feature.py:
101 |   - MIRROR pattern from: src/similar_feature.py
102 |   - MODIFY class name and core logic
103 |   - KEEP error handling pattern identical
104 | 
105 | ...(...)
106 | 
107 | Task N:
108 | ...
109 | 
110 | ```
111 | 
112 | ### Per task pseudocode as needed added to each task
113 | 
114 | ```python
115 | 
116 | # Task 1
117 | # Pseudocode with CRITICAL details dont write entire code
118 | async def new_feature(param: str) -> Result:
119 |     # PATTERN: Always validate input first (see src/validators.py)
120 |     validated = validate_input(param)  # raises ValidationError
121 |     
122 |     # GOTCHA: This library requires connection pooling
123 |     async with get_connection() as conn:  # see src/db/pool.py
124 |         # PATTERN: Use existing retry decorator
125 |         @retry(attempts=3, backoff=exponential)
126 |         async def _inner():
127 |             # CRITICAL: API returns 429 if >10 req/sec
128 |             await rate_limiter.acquire()
129 |             return await external_api.call(validated)
130 |         
131 |         result = await _inner()
132 |     
133 |     # PATTERN: Standardized response format
134 |     return format_response(result)  # see src/utils/responses.py
135 | ```
136 | 
137 | ### Integration Points
138 | 
139 | ```yaml
140 | DATABASE:
141 |   - migration: "Add column 'feature_enabled' to users table"
142 |   - index: "CREATE INDEX idx_feature_lookup ON users(feature_id)"
143 |   
144 | CONFIG:
145 |   - add to: config/settings.py
146 |   - pattern: "FEATURE_TIMEOUT = int(os.getenv('FEATURE_TIMEOUT', '30'))"
147 |   
148 | ROUTES:
149 |   - add to: src/api/routes.py  
150 |   - pattern: "router.include_router(feature_router, prefix='/feature')"
151 | ```
152 | 
153 | ## Validation Loop
154 | 
155 | ### Level 1: Syntax & Style
156 | 
157 | ```bash
158 | # Run these FIRST - fix any errors before proceeding
159 | ruff check src/new_feature.py --fix  # Auto-fix what's possible
160 | mypy src/new_feature.py              # Type checking
161 | 
162 | # Expected: No errors. If errors, READ the error and fix.
163 | ```
164 | 
165 | ### Level 2: Unit Tests each new feature/file/function use existing test patterns
166 | 
167 | ```python
168 | # CREATE test_new_feature.py with these test cases:
169 | def test_happy_path():
170 |     """Basic functionality works"""
171 |     result = new_feature("valid_input")
172 |     assert result.status == "success"
173 | 
174 | def test_validation_error():
175 |     """Invalid input raises ValidationError"""
176 |     with pytest.raises(ValidationError):
177 |         new_feature("")
178 | 
179 | def test_external_api_timeout():
180 |     """Handles timeouts gracefully"""
181 |     with mock.patch('external_api.call', side_effect=TimeoutError):
182 |         result = new_feature("valid")
183 |         assert result.status == "error"
184 |         assert "timeout" in result.message
185 | ```
186 | 
187 | ```bash
188 | # Run and iterate until passing:
189 | uv run pytest test_new_feature.py -v
190 | # If failing: Read error, understand root cause, fix code, re-run (never mock to pass)
191 | ```
192 | 
193 | ### Level 3: Integration Test
194 | 
195 | ```bash
196 | # Start the service
197 | uv run python -m src.main --dev
198 | 
199 | # Test the endpoint
200 | curl -X POST http://localhost:8000/feature \
201 |   -H "Content-Type: application/json" \
202 |   -d '{"param": "test_value"}'
203 | 
204 | # Expected: {"status": "success", "data": {...}}
205 | # If error: Check logs at logs/app.log for stack trace
206 | ```
207 | 
208 | ## Final validation Checklist
209 | 
210 | - [ ] All tests pass: `uv run pytest tests/ -v`
211 | - [ ] No linting errors: `uv run ruff check src/`
212 | - [ ] No type errors: `uv run mypy src/`
213 | - [ ] Manual test successful: [specific curl/command]
214 | - [ ] Error cases handled gracefully
215 | - [ ] Logs are informative but not verbose
216 | - [ ] Documentation updated if needed
217 | 
218 | ---
219 | 
220 | ## Anti-Patterns to Avoid
221 | 
222 | - ❌ Don't create new patterns when existing ones work
223 | - ❌ Don't skip validation because "it should work"  
224 | - ❌ Don't ignore failing tests - fix them
225 | - ❌ Don't use sync functions in async context
226 | - ❌ Don't hardcode values that should be config
227 | - ❌ Don't catch all exceptions - be specific
228 | 


--------------------------------------------------------------------------------
/docs/architecture/sequence_diagram.mermaid:
--------------------------------------------------------------------------------
 1 | sequenceDiagram
 2 |     participant User
 3 |     participant feature_DESC_XXX.md
 4 |     participant ClaudeCode
 5 |     participant generate-prp.md
 6 |     participant feature_PRP_XXX.md
 7 |     participant execute-prp.md
 8 |     participant AI Coding Agent
 9 | 
10 |     User->>/context/features/feature_DESC_XXX.md: Describes feature
11 |     User->>ClaudeCode: Runs /generate-prp.md /context/features/feature_DESC_XXX.md
12 |     ClaudeCode->>generate-prp.md: Executes command
13 |     generate-prp.md->>AI Coding Agent: Reads /context/features/feature_DESC_XXX.md, codebase, and web
14 |     AI Coding Agent-->>generate-prp.md: Researches codebase, docs, and examples
15 |     generate-prp.md->>/context/features/feature_PRP_XXX.md: Generates PRP
16 |     ClaudeCode->>User: PRP saved in /context/PRPs/feature_PRP_XXX.md
17 |     User->>ClaudeCode: Runs /execute-prp /context/PRPs/feature_PRP_XXX.md
18 |     ClaudeCode->>execute-prp.md: Executes command
19 |     execute-prp.md->>AI Coding Agent: Reads /context/PRPs/feature_PRP_XXX.md and CLAUDE.md
20 |     AI Coding Agent->>AI Coding Agent: Creates implementation plan, executes, validates, and iterates
21 |     AI Coding Agent-->>User: Implements feature
22 | 


--------------------------------------------------------------------------------
/mkdocs.yaml:
--------------------------------------------------------------------------------
 1 | ---
 2 | # https://github.com/james-willett/mkdocs-material-youtube-tutorial
 3 | # https://mkdocstrings.github.io/recipes/
 4 | # site info set in workflow
 5 | site_name: '<gha_sed_site_name_here>'
 6 | site_description: '<gha_sed_site_description_here>'
 7 | repo_url: '<gha_sed_repo_url_here>'
 8 | edit_uri: edit/main
 9 | theme:
10 |   name: material
11 |   language: en
12 |   features:
13 |     - content.code.annotation
14 |     - content.code.copy
15 |     - content.tabs.link
16 |     - navigation.footer
17 |     - navigation.sections
18 |     - navigation.tabs
19 |     - navigation.top
20 |     - toc.integrate
21 |     - search.suggest
22 |     - search.highlight
23 |   palette:
24 |     - media: "(prefers-color-scheme: light)"
25 |       scheme: default
26 |       toggle:
27 |         # icon: material/brightness-7
28 |         icon: material/toggle-switch-off-outline 
29 |         name: "Toggle Dark Mode"
30 |     - media: "(prefers-color-scheme: dark)"
31 |       scheme: slate
32 |       toggle:
33 |         # icon: material/brightness-4
34 |         icon: material/toggle-switch
35 |         name: "Toggle Light Mode"
36 | nav:
37 |   - Home: index.md
38 |   - Code: docstrings.md
39 |   - Change Log: CHANGELOG.md
40 |   - License: LICENSE
41 |   - llms.txt: llms.txt
42 | plugins:
43 |   - search:
44 |       lang: en
45 |   - autorefs
46 |   - mkdocstrings:
47 |       handlers:
48 |         python:
49 |           paths: [src]
50 |           options:
51 |             show_root_heading: true
52 |             show_root_full_path: true
53 |             show_object_full_path: false
54 |             show_root_members_full_path: false
55 |             show_category_heading: true
56 |             show_submodules: true
57 | markdown_extensions:
58 |   - attr_list
59 |   - pymdownx.magiclink
60 |   - pymdownx.tabbed
61 |   - pymdownx.highlight:
62 |       anchor_linenums: true
63 |   - pymdownx.superfences
64 |   - pymdownx.snippets:
65 |       check_paths: true
66 |   - pymdownx.tasklist:
67 |       custom_checkbox: true
68 |   - sane_lists
69 |   - smarty
70 |   - toc:
71 |       permalink: true
72 | validation:
73 |   links:
74 |     not_found: warn
75 |     anchors: warn
76 | # builds only if validation succeeds while
77 | # threating warnings as errors
78 | # also checks for broken links
79 | # strict: true
80 | ...
81 | 


--------------------------------------------------------------------------------
/pyproject.toml:
--------------------------------------------------------------------------------
  1 | [build-system]
  2 | requires = ["hatchling"]
  3 | build-backend = "hatchling.build"
  4 | 
  5 | [project]
  6 | version = "0.0.1"
  7 | name = "context-engineering-template"
  8 | description = "Assess the effectiveness of agentic AI systems across various use cases focusing on agnostic metrics that measure core agentic capabilities."
  9 | authors = [
 10 |     {name = "qte77", email = "qte@77.gh"}
 11 | ]
 12 | readme = "README.md"
 13 | requires-python = "==3.13.*"
 14 | license = "bsd-3-clause"
 15 | dependencies = [
 16 |     "mcp[cli]>=1.10.0",
 17 |     "httpx>=0.25.0",
 18 |     "pydantic>=2.0.0",
 19 |     "streamlit>=1.28.0",
 20 | ]
 21 | 
 22 | # [project.urls]
 23 | # Documentation = ""
 24 | 
 25 | [dependency-groups]
 26 | dev = [
 27 |     "mypy>=1.16.0",
 28 |     "ruff>=0.11.12",
 29 | ]
 30 | test = [
 31 |     "pytest>=7.0.0",
 32 |     "pytest-asyncio>=0.21.0",
 33 |     "pytest-httpx>=0.28.0",
 34 | ]
 35 | docs = [
 36 |     "griffe>=1.5.1",
 37 |     "mkdocs>=1.6.1",
 38 |     "mkdocs-awesome-pages-plugin>=2.9.3",
 39 |     "mkdocs-gen-files>=0.5.0",
 40 |     "mkdocs-literate-nav>=0.6.1",
 41 |     "mkdocs-material>=9.5.44",
 42 |     "mkdocs-section-index>=0.3.8",
 43 |     "mkdocstrings[python]>=0.27.0",
 44 | ]
 45 | 
 46 | [tool.uv]
 47 | package = true
 48 | exclude-newer = "2025-07-06T00:00:00Z"
 49 | 
 50 | [tool.hatch.build.targets.wheel]
 51 | only-include = ["/README.md"]
 52 | 
 53 | [tool.hatch.build.targets.sdist]
 54 | include = ["/README.md", "/Makefile", "/tests"]
 55 | 
 56 | [tool.ruff]
 57 | target-version = "py313"
 58 | src = ["src", "tests"]
 59 | 
 60 | [tool.ruff.format]
 61 | docstring-code-format = true
 62 | 
 63 | [tool.ruff.lint]
 64 | # ignore = ["E203"]  # Whitespace before ':'
 65 | unfixable = ["B"]
 66 | select = [
 67 |     # pycodestyle
 68 |     "E",
 69 |     # Pyflakes
 70 |     "F",
 71 |     # pyupgrade
 72 |     "UP",
 73 |     # isort
 74 |     "I",
 75 | ]
 76 | 
 77 | [tool.ruff.lint.isort]
 78 | known-first-party = ["src", "tests"]
 79 | 
 80 | [tool.ruff.lint.pydocstyle]
 81 | convention = "google"
 82 | 
 83 | [tool.mypy]
 84 | python_version = "3.13"
 85 | strict = true
 86 | disallow_untyped_defs = true
 87 | disallow_any_generics = true
 88 | warn_redundant_casts = true
 89 | warn_unused_ignores = true
 90 | warn_return_any = true
 91 | warn_unreachable = true
 92 | show_error_codes = true
 93 | namespace_packages = true
 94 | explicit_package_bases = true
 95 | mypy_path = "src"
 96 | 
 97 | [tool.pytest.ini_options]
 98 | addopts = "--strict-markers"
 99 | # "function", "class", "module", "package", "session"
100 | asyncio_default_fixture_loop_scope = "function"
101 | pythonpath = ["src"]
102 | testpaths = ["tests/"]
103 | 
104 | [tool.coverage]
105 | [tool.coverage.run]
106 | include = [
107 |     "tests/**/*.py",
108 | ]
109 | # omit = []
110 | # branch = true
111 | 
112 | [tool.coverage.report]
113 | show_missing = true
114 | exclude_lines = [
115 |     # 'pragma: no cover',
116 |     'raise AssertionError',
117 |     'raise NotImplementedError',
118 | ]
119 | omit = [
120 |     'env/*',
121 |     'venv/*',
122 |     '.venv/*',
123 |     '*/virtualenv/*',
124 |     '*/virtualenvs/*',
125 |     '*/tests/*',
126 | ]
127 | 
128 | [tool.bumpversion]
129 | current_version = "0.0.1"
130 | parse = "(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)"
131 | serialize = ["{major}.{minor}.{patch}"]
132 | commit = true
133 | tag = true
134 | allow_dirty = false
135 | ignore_missing_version = false
136 | sign_tags = false
137 | tag_name = "v{new_version}"
138 | tag_message = "Bump version: {current_version} → {new_version}"
139 | message = "Bump version: {current_version} → {new_version}"
140 | commit_args = ""
141 | 
142 | [[tool.bumpversion.files]]
143 | filename = "pyproject.toml"
144 | search = 'version = "{current_version}"'
145 | replace = 'version = "{new_version}"'
146 | 
147 | [[tool.bumpversion.files]]
148 | filename = "src/__init__.py"
149 | search = '__version__ = "{current_version}"'
150 | replace = '__version__ = "{new_version}"'
151 | 
152 | [[tool.bumpversion.files]]
153 | filename = "README.md"
154 | search = "version-{current_version}-58f4c2"
155 | replace = "version-{new_version}-58f4c2"
156 | 
157 | [[tool.bumpversion.files]]
158 | filename = "CHANGELOG.md"
159 | search = """
160 | ## [Unreleased]
161 | """
162 | replace = """
163 | ## [Unreleased]
164 | 
165 | ## [{new_version}] - {now:%Y-%m-%d}
166 | """


--------------------------------------------------------------------------------
/src/__init__.py:
--------------------------------------------------------------------------------
1 | """Defines the application version."""
2 | 
3 | __version__ = "0.0.1"
4 | 


--------------------------------------------------------------------------------
/src/gui/__init__.py:
--------------------------------------------------------------------------------
1 | """GUI module for MCP client interface."""
2 | 


--------------------------------------------------------------------------------
/src/gui/app.py:
--------------------------------------------------------------------------------
 1 | """Main Streamlit application for MCP Tool Showcase."""
 2 | 
 3 | import streamlit as st
 4 | 
 5 | from .components.connection import ConnectionManager
 6 | from .components.history import HistoryManager
 7 | from .components.tool_forms import ToolForms
 8 | from .models.gui_models import GUISession
 9 | 
10 | 
11 | def main() -> None:
12 |     """Main Streamlit application entry point."""
13 |     st.set_page_config(
14 |         page_title="MCP Tool Showcase",
15 |         page_icon="🛠️",
16 |         layout="wide",
17 |         initial_sidebar_state="expanded",
18 |     )
19 | 
20 |     # Initialize session state
21 |     if "gui_session" not in st.session_state:
22 |         st.session_state.gui_session = GUISession()
23 | 
24 |     if "mcp_client" not in st.session_state:
25 |         st.session_state.mcp_client = None
26 | 
27 |     # Main layout with sidebar
28 |     with st.sidebar:
29 |         st.title("🛠️ MCP Tool Showcase")
30 |         st.markdown("---")
31 | 
32 |         # Connection management
33 |         connection_manager = ConnectionManager()
34 |         connection_manager.render()
35 | 
36 |     # Main content area
37 |     col1, col2 = st.columns([1, 1])
38 | 
39 |     with col1:
40 |         st.header("Tool Invocation")
41 |         if st.session_state.gui_session.connected:
42 |             tool_forms = ToolForms()
43 |             tool_forms.render()
44 |         else:
45 |             st.info("Please connect to the MCP server first")
46 | 
47 |     with col2:
48 |         st.header("Request/Response")
49 |         if st.session_state.gui_session.interaction_history:
50 |             latest_interaction = st.session_state.gui_session.interaction_history[-1]
51 |             st.subheader("Latest Request")
52 |             st.json(latest_interaction.request_payload)
53 |             st.subheader("Latest Response")
54 |             st.json(latest_interaction.response_payload)
55 |         else:
56 |             st.info("No interactions yet")
57 | 
58 |     # History section
59 |     st.header("Interaction History")
60 |     history_manager = HistoryManager()
61 |     history_manager.render()
62 | 
63 | 
64 | if __name__ == "__main__":
65 |     main()
66 | 


--------------------------------------------------------------------------------
/src/gui/components/__init__.py:
--------------------------------------------------------------------------------
1 | """GUI components for reusable interface elements."""
2 | 


--------------------------------------------------------------------------------
/src/gui/components/connection.py:
--------------------------------------------------------------------------------
 1 | """Connection management component for MCP server."""
 2 | 
 3 | import asyncio
 4 | import logging
 5 | 
 6 | import streamlit as st
 7 | 
 8 | from src.mcp_client.client import MCPClient
 9 | 
10 | logger = logging.getLogger(__name__)
11 | 
12 | 
13 | class ConnectionManager:
14 |     """Manages MCP server connection in GUI."""
15 | 
16 |     def render(self) -> None:
17 |         """Render connection management interface."""
18 |         st.subheader("Connection Status")
19 | 
20 |         # Display current status
21 |         if st.session_state.gui_session.connected:
22 |             st.success("✅ Connected to MCP Server")
23 |             st.write(f"Server: {st.session_state.gui_session.server_path}")
24 |             tools = ', '.join(st.session_state.gui_session.available_tools)
25 |             st.write(f"Available Tools: {tools}")
26 | 
27 |             # Health check button
28 |             if st.button("Health Check"):
29 |                 self._perform_health_check()
30 | 
31 |             # Disconnect button
32 |             if st.button("Disconnect"):
33 |                 self._disconnect()
34 |         else:
35 |             st.error("❌ Not Connected")
36 | 
37 |             # Connection form
38 |             server_path = st.text_input(
39 |                 "Server Path",
40 |                 value=st.session_state.gui_session.server_path,
41 |                 help="Path to MCP server script",
42 |             )
43 | 
44 |             if st.button("Connect"):
45 |                 self._connect(server_path)
46 | 
47 |     def _connect(self, server_path: str) -> None:
48 |         """Connect to MCP server."""
49 |         try:
50 |             with st.spinner("Connecting to server..."):
51 |                 # Handle async in Streamlit
52 |                 client = MCPClient(server_path)
53 |                 asyncio.run(client.connect())
54 | 
55 |                 st.session_state.mcp_client = client
56 |                 st.session_state.gui_session.connected = True
57 |                 st.session_state.gui_session.server_path = server_path
58 |                 st.session_state.gui_session.available_tools = client.available_tools
59 | 
60 |                 st.success("Connected successfully!")
61 |                 st.rerun()
62 | 
63 |         except Exception as e:
64 |             logger.error(f"Connection failed: {e}")
65 |             st.error(f"Connection failed: {str(e)}")
66 | 
67 |     def _disconnect(self) -> None:
68 |         """Disconnect from MCP server."""
69 |         if st.session_state.mcp_client:
70 |             try:
71 |                 asyncio.run(st.session_state.mcp_client.disconnect())
72 |                 st.session_state.mcp_client = None
73 |                 st.session_state.gui_session.connected = False
74 |                 st.session_state.gui_session.available_tools = []
75 |                 st.success("Disconnected successfully!")
76 |                 st.rerun()
77 |             except Exception as e:
78 |                 logger.error(f"Disconnect failed: {e}")
79 |                 st.error(f"Disconnect failed: {str(e)}")
80 | 
81 |     def _perform_health_check(self) -> None:
82 |         """Perform health check on connection."""
83 |         if st.session_state.mcp_client:
84 |             try:
85 |                 health = asyncio.run(st.session_state.mcp_client.health_check())
86 |                 if health:
87 |                     st.success("Health check passed!")
88 |                 else:
89 |                     st.warning("Health check failed - connection may be unhealthy")
90 |             except Exception as e:
91 |                 logger.error(f"Health check error: {e}")
92 |                 st.error(f"Health check error: {str(e)}")
93 | 


--------------------------------------------------------------------------------
/src/gui/components/history.py:
--------------------------------------------------------------------------------
 1 | """History management component for interaction tracking."""
 2 | 
 3 | import streamlit as st
 4 | 
 5 | from ..models.gui_models import GUIInteraction
 6 | 
 7 | 
 8 | class HistoryManager:
 9 |     """Manages session history display and interaction."""
10 | 
11 |     def render(self) -> None:
12 |         """Render interaction history interface."""
13 |         history = st.session_state.gui_session.interaction_history
14 | 
15 |         if not history:
16 |             st.info(
17 |                 "No interactions yet. Connect to a server and use tools to see history."
18 |             )
19 |             return
20 | 
21 |         # History controls
22 |         col1, col2 = st.columns([1, 1])
23 | 
24 |         with col1:
25 |             st.write(f"**Total Interactions:** {len(history)}")
26 | 
27 |         with col2:
28 |             if st.button("Clear History"):
29 |                 st.session_state.gui_session.interaction_history = []
30 |                 st.rerun()
31 | 
32 |         # Display history
33 |         for i, interaction in enumerate(reversed(history)):
34 |             self._render_interaction(i, interaction)
35 | 
36 |     def _render_interaction(self, index: int, interaction: GUIInteraction) -> None:
37 |         """Render a single interaction."""
38 |         # Create expander with status indicator
39 |         status_icon = "✅" if interaction.success else "❌"
40 |         timestamp = interaction.timestamp.strftime("%H:%M:%S")
41 | 
42 |         with st.expander(
43 |             f"{status_icon} {interaction.tool_name} - {timestamp}",
44 |             expanded=index == 0,  # Expand latest interaction
45 |         ):
46 |             # Basic info
47 |             col1, col2 = st.columns([1, 1])
48 | 
49 |             with col1:
50 |                 st.write(f"**Tool:** {interaction.tool_name}")
51 |                 st.write(
52 |                     f"**Status:** {'Success' if interaction.success else 'Failed'}"
53 |                 )
54 |                 if interaction.execution_time:
55 |                     st.write(f"**Execution Time:** {interaction.execution_time:.2f}s")
56 | 
57 |             with col2:
58 |                 timestamp_str = interaction.timestamp.strftime('%Y-%m-%d %H:%M:%S')
59 |                 st.write(f"**Timestamp:** {timestamp_str}")
60 |                 if interaction.error_message:
61 |                     st.write(f"**Error:** {interaction.error_message}")
62 | 
63 |             # Request/Response payloads
64 |             req_col, resp_col = st.columns([1, 1])
65 | 
66 |             with req_col:
67 |                 st.subheader("Request")
68 |                 st.json(interaction.request_payload)
69 | 
70 |             with resp_col:
71 |                 st.subheader("Response")
72 |                 st.json(interaction.response_payload)
73 | 


--------------------------------------------------------------------------------
/src/gui/components/tool_forms.py:
--------------------------------------------------------------------------------
  1 | """Tool-specific form components for MCP tools."""
  2 | 
  3 | import asyncio
  4 | import logging
  5 | import re
  6 | import time
  7 | 
  8 | import streamlit as st
  9 | 
 10 | from ..models.gui_models import GUIInteraction
 11 | 
 12 | logger = logging.getLogger(__name__)
 13 | 
 14 | 
 15 | class ToolForms:
 16 |     """Manages tool-specific form interfaces."""
 17 | 
 18 |     def render(self) -> None:
 19 |         """Render tool selection and forms."""
 20 |         available_tools = st.session_state.gui_session.available_tools
 21 | 
 22 |         if not available_tools:
 23 |             st.warning("No tools available")
 24 |             return
 25 | 
 26 |         # Tool selection
 27 |         selected_tool = st.selectbox(
 28 |             "Select Tool", options=available_tools, help="Choose a tool to invoke"
 29 |         )
 30 | 
 31 |         # Tool-specific forms
 32 |         if selected_tool == "roll_dice":
 33 |             self._render_dice_form()
 34 |         elif selected_tool == "get_weather":
 35 |             self._render_weather_form()
 36 |         elif selected_tool == "get_date":
 37 |             self._render_date_form()
 38 | 
 39 |     def _render_dice_form(self) -> None:
 40 |         """Render dice rolling form."""
 41 |         with st.form("dice_form"):
 42 |             st.subheader("🎲 Roll Dice")
 43 | 
 44 |             notation = st.text_input(
 45 |                 "Dice Notation",
 46 |                 value="2d6",
 47 |                 help="Enter dice notation (e.g., 2d6, 1d20, 3d10)",
 48 |             )
 49 | 
 50 |             # Help text with examples
 51 |             st.caption("Examples: 1d20 (single 20-sided die), 3d6 (three 6-sided dice)")
 52 | 
 53 |             submitted = st.form_submit_button("Roll Dice")
 54 | 
 55 |             if submitted:
 56 |                 if self._validate_dice_notation(notation):
 57 |                     self._execute_tool("roll_dice", {"notation": notation})
 58 |                 else:
 59 |                     st.error("Invalid dice notation. Use format like '2d6' or '1d20'")
 60 | 
 61 |     def _render_weather_form(self) -> None:
 62 |         """Render weather lookup form."""
 63 |         with st.form("weather_form"):
 64 |             st.subheader("🌤️ Get Weather")
 65 | 
 66 |             location = st.text_input(
 67 |                 "Location",
 68 |                 value="San Francisco",
 69 |                 help="Enter city name or coordinates (lat,lon)",
 70 |             )
 71 | 
 72 |             # Common location examples
 73 |             st.caption("Examples: London, New York, 37.7749,-122.4194")
 74 | 
 75 |             submitted = st.form_submit_button("Get Weather")
 76 | 
 77 |             if submitted:
 78 |                 if location.strip():
 79 |                     self._execute_tool("get_weather", {"location": location})
 80 |                 else:
 81 |                     st.error("Please enter a location")
 82 | 
 83 |     def _render_date_form(self) -> None:
 84 |         """Render date/time lookup form."""
 85 |         with st.form("date_form"):
 86 |             st.subheader("🕐 Get Date & Time")
 87 | 
 88 |             timezone = st.selectbox(
 89 |                 "Timezone",
 90 |                 options=[
 91 |                     "UTC",
 92 |                     "America/New_York",
 93 |                     "America/Los_Angeles",
 94 |                     "Europe/London",
 95 |                     "Asia/Tokyo",
 96 |                     "Australia/Sydney",
 97 |                 ],
 98 |                 help="Select timezone or enter custom IANA timezone",
 99 |             )
100 | 
101 |             custom_timezone = st.text_input(
102 |                 "Custom Timezone (optional)",
103 |                 placeholder="e.g., America/Chicago",
104 |                 help="Enter custom IANA timezone identifier",
105 |             )
106 | 
107 |             submitted = st.form_submit_button("Get Date & Time")
108 | 
109 |             if submitted:
110 |                 tz = custom_timezone.strip() if custom_timezone.strip() else timezone
111 |                 self._execute_tool("get_date", {"timezone": tz})
112 | 
113 |     def _execute_tool(self, tool_name: str, arguments: dict[str, str]) -> None:
114 |         """Execute tool and update GUI state."""
115 |         if not st.session_state.mcp_client:
116 |             st.error("Not connected to server")
117 |             return
118 | 
119 |         try:
120 |             with st.spinner(f"Executing {tool_name}..."):
121 |                 # Time execution for performance metrics
122 |                 start_time = time.time()
123 | 
124 |                 # Use existing MCP client
125 |                 result = asyncio.run(
126 |                     st.session_state.mcp_client.invoke_tool(tool_name, arguments)
127 |                 )
128 | 
129 |                 execution_time = time.time() - start_time
130 | 
131 |                 # Create interaction record
132 |                 interaction = GUIInteraction(
133 |                     tool_name=tool_name,
134 |                     arguments=arguments,
135 |                     request_payload={"tool": tool_name, "arguments": arguments},
136 |                     response_payload=result.model_dump(),
137 |                     success=result.success,
138 |                     error_message=result.error if not result.success else None,
139 |                     execution_time=execution_time,
140 |                 )
141 | 
142 |                 # Update session state
143 |                 st.session_state.gui_session.interaction_history.append(interaction)
144 | 
145 |                 # Display result
146 |                 if result.success:
147 |                     st.success(f"✅ {tool_name} executed successfully!")
148 |                     st.json(result.model_dump())
149 |                 else:
150 |                     st.error(f"❌ {tool_name} failed: {result.error}")
151 | 
152 |                 st.rerun()
153 | 
154 |         except Exception as e:
155 |             logger.error(f"Tool execution error: {e}")
156 |             st.error(f"Execution error: {str(e)}")
157 | 
158 |     def _validate_dice_notation(self, notation: str) -> bool:
159 |         """Validate dice notation format."""
160 |         pattern = r"^(\d+)d(\d+)

quot;
161 |         return bool(re.match(pattern, notation.strip().lower()))
162 | 


--------------------------------------------------------------------------------
/src/gui/models/__init__.py:
--------------------------------------------------------------------------------
1 | """GUI models for state management and data validation."""
2 | 


--------------------------------------------------------------------------------
/src/gui/models/gui_models.py:
--------------------------------------------------------------------------------
 1 | """GUI-specific models for state management and type safety."""
 2 | 
 3 | from datetime import datetime
 4 | from typing import Any
 5 | 
 6 | from pydantic import BaseModel, Field
 7 | 
 8 | 
 9 | class GUIInteraction(BaseModel):
10 |     """Single tool interaction record for GUI history."""
11 | 
12 |     timestamp: datetime = Field(default_factory=datetime.now)
13 |     tool_name: str
14 |     arguments: dict[str, Any]
15 |     request_payload: dict[str, Any]
16 |     response_payload: dict[str, Any]
17 |     success: bool
18 |     error_message: str | None = None
19 |     execution_time: float | None = None
20 | 
21 | 
22 | class GUISession(BaseModel):
23 |     """GUI session state management."""
24 | 
25 |     connected: bool = False
26 |     server_path: str = "src/mcp_server/server.py"
27 |     available_tools: list[str] = Field(default_factory=list)
28 |     interaction_history: list[GUIInteraction] = Field(default_factory=list)
29 |     current_tool: str | None = None
30 | 
31 | 
32 | class ConnectionStatus(BaseModel):
33 |     """Connection status information."""
34 | 
35 |     connected: bool = False
36 |     server_path: str
37 |     last_health_check: datetime | None = None
38 |     available_tools: list[str] = Field(default_factory=list)
39 |     error_message: str | None = None
40 | 


--------------------------------------------------------------------------------
/src/gui/utils/__init__.py:
--------------------------------------------------------------------------------
1 | """GUI utilities for formatting and validation."""
2 | 


--------------------------------------------------------------------------------
/src/gui/utils/formatting.py:
--------------------------------------------------------------------------------
 1 | """Formatting utilities for GUI display."""
 2 | 
 3 | import json
 4 | from typing import Any
 5 | 
 6 | 
 7 | def format_json_for_display(data: Any, indent: int = 2) -> str:
 8 |     """Format JSON data for display with proper indentation.
 9 | 
10 |     Args:
11 |         data: Data to format as JSON
12 |         indent: Number of spaces for indentation
13 | 
14 |     Returns:
15 |         Formatted JSON string
16 |     """
17 |     try:
18 |         return json.dumps(data, indent=indent, ensure_ascii=False)
19 |     except (TypeError, ValueError) as e:
20 |         return f"Error formatting JSON: {str(e)}"
21 | 
22 | 
23 | def format_error_message(error: str) -> str:
24 |     """Format error messages for user-friendly display.
25 | 
26 |     Args:
27 |         error: Raw error message
28 | 
29 |     Returns:
30 |         Formatted error message
31 |     """
32 |     # Remove common Python error prefixes
33 |     error = error.replace("Exception: ", "")
34 |     error = error.replace("Error: ", "")
35 | 
36 |     # Capitalize first letter
37 |     if error:
38 |         error = error[0].upper() + error[1:]
39 | 
40 |     return error
41 | 
42 | 
43 | def format_execution_time(seconds: float) -> str:
44 |     """Format execution time for display.
45 | 
46 |     Args:
47 |         seconds: Execution time in seconds
48 | 
49 |     Returns:
50 |         Formatted time string
51 |     """
52 |     if seconds < 1:
53 |         return f"{seconds * 1000:.0f}ms"
54 |     elif seconds < 60:
55 |         return f"{seconds:.2f}s"
56 |     else:
57 |         minutes = int(seconds // 60)
58 |         remaining_seconds = seconds % 60
59 |         return f"{minutes}m {remaining_seconds:.1f}s"
60 | 
61 | 
62 | def truncate_text(text: str, max_length: int = 100) -> str:
63 |     """Truncate text with ellipsis if too long.
64 | 
65 |     Args:
66 |         text: Text to truncate
67 |         max_length: Maximum length before truncation
68 | 
69 |     Returns:
70 |         Truncated text with ellipsis if needed
71 |     """
72 |     if len(text) <= max_length:
73 |         return text
74 |     return text[: max_length - 3] + "..."
75 | 


--------------------------------------------------------------------------------
/src/gui/utils/validation.py:
--------------------------------------------------------------------------------
  1 | """Validation utilities for GUI input."""
  2 | 
  3 | import re
  4 | 
  5 | 
  6 | def validate_dice_notation(notation: str) -> bool:
  7 |     """Validate dice notation format.
  8 | 
  9 |     Args:
 10 |         notation: Dice notation string (e.g., "2d6", "1d20")
 11 | 
 12 |     Returns:
 13 |         True if valid, False otherwise
 14 |     """
 15 |     if not notation or not isinstance(notation, str):
 16 |         return False
 17 | 
 18 |     # Pattern: number + 'd' + number
 19 |     pattern = r"^(\d+)d(\d+)

quot;
 20 |     match = re.match(pattern, notation.strip().lower())
 21 | 
 22 |     if not match:
 23 |         return False
 24 | 
 25 |     # Check reasonable limits
 26 |     num_dice = int(match.group(1))
 27 |     num_sides = int(match.group(2))
 28 | 
 29 |     # Validate ranges
 30 |     if num_dice < 1 or num_dice > 100:
 31 |         return False
 32 |     if num_sides < 2 or num_sides > 1000:
 33 |         return False
 34 | 
 35 |     return True
 36 | 
 37 | 
 38 | def validate_location(location: str) -> bool:
 39 |     """Validate location input for weather lookup.
 40 | 
 41 |     Args:
 42 |         location: Location string (city name or coordinates)
 43 | 
 44 |     Returns:
 45 |         True if valid, False otherwise
 46 |     """
 47 |     if not location or not isinstance(location, str):
 48 |         return False
 49 | 
 50 |     location = location.strip()
 51 | 
 52 |     # Check for coordinates format (lat,lon)
 53 |     coord_pattern = r"^-?\d+\.?\d*,-?\d+\.?\d*

quot;
 54 |     if re.match(coord_pattern, location):
 55 |         return True
 56 | 
 57 |     # Check for city name (at least 2 characters, letters and spaces)
 58 |     city_pattern = r"^[a-zA-Z\s]{2,}

quot;
 59 |     if re.match(city_pattern, location):
 60 |         return True
 61 | 
 62 |     return False
 63 | 
 64 | 
 65 | def validate_timezone(timezone: str) -> bool:
 66 |     """Validate timezone identifier.
 67 | 
 68 |     Args:
 69 |         timezone: Timezone string (IANA format)
 70 | 
 71 |     Returns:
 72 |         True if valid, False otherwise
 73 |     """
 74 |     if not timezone or not isinstance(timezone, str):
 75 |         return False
 76 | 
 77 |     timezone = timezone.strip()
 78 | 
 79 |     # Common timezone patterns
 80 |     common_timezones = [
 81 |         "UTC",
 82 |         "GMT",
 83 |         "EST",
 84 |         "PST",
 85 |         "CST",
 86 |         "MST",
 87 |         "America/New_York",
 88 |         "America/Los_Angeles",
 89 |         "America/Chicago",
 90 |         "Europe/London",
 91 |         "Europe/Paris",
 92 |         "Asia/Tokyo",
 93 |         "Australia/Sydney",
 94 |     ]
 95 | 
 96 |     if timezone in common_timezones:
 97 |         return True
 98 | 
 99 |     # IANA timezone format: Area/City or Area/Region/City
100 |     iana_pattern = r"^[A-Za-z_]+/[A-Za-z_]+(?:/[A-Za-z_]+)?

quot;
101 |     return bool(re.match(iana_pattern, timezone))
102 | 
103 | 
104 | def validate_server_path(path: str) -> str | None:
105 |     """Validate server path and return error message if invalid.
106 | 
107 |     Args:
108 |         path: Server path string
109 | 
110 |     Returns:
111 |         Error message if invalid, None if valid
112 |     """
113 |     if not path or not isinstance(path, str):
114 |         return "Server path is required"
115 | 
116 |     path = path.strip()
117 | 
118 |     if not path:
119 |         return "Server path cannot be empty"
120 | 
121 |     if not path.endswith(".py"):
122 |         return "Server path must be a Python file (.py)"
123 | 
124 |     # Basic path validation
125 |     if ".." in path or path.startswith("/"):
126 |         return "Server path should be relative to project root"
127 | 
128 |     return None
129 | 


--------------------------------------------------------------------------------
/src/main.py:
--------------------------------------------------------------------------------
  1 | """Main entry point for the MCP server and client applications."""
  2 | 
  3 | import argparse
  4 | import logging
  5 | import sys
  6 | from asyncio import run
  7 | 
  8 | from src.mcp_client.cli import MCPClientCLI
  9 | from src.mcp_server import run_server
 10 | 
 11 | 
 12 | def setup_logging(level: str = "INFO") -> None:
 13 |     """Setup logging configuration."""
 14 |     logging.basicConfig(
 15 |         level=getattr(logging, level.upper()),
 16 |         format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
 17 |         datefmt="%Y-%m-%d %H:%M:%S",
 18 |     )
 19 | 
 20 | 
 21 | async def main() -> None:
 22 |     """Main entry point for MCP applications."""
 23 |     parser = argparse.ArgumentParser(
 24 |         description="MCP Server and Client with dice, weather, and date/time tools",
 25 |         formatter_class=argparse.RawDescriptionHelpFormatter,
 26 |         epilog="""
 27 | Examples:
 28 |   # Run MCP server
 29 |   %(prog)s server
 30 |   
 31 |   # Run MCP client
 32 |   %(prog)s client --server ./server.py roll_dice --notation 2d6
 33 |   %(prog)s client --server ./server.py get_weather --location "San Francisco"
 34 |   %(prog)s client --server ./server.py get_date --timezone UTC
 35 |   
 36 |   # Launch Streamlit GUI
 37 |   %(prog)s gui
 38 |   %(prog)s gui --port 8502
 39 | """
 40 |     )
 41 |     
 42 |     # Add subcommands
 43 |     subparsers = parser.add_subparsers(
 44 |         dest='mode',
 45 |         help='Choose server or client mode',
 46 |         metavar='MODE'
 47 |     )
 48 |     
 49 |     # Server subcommand
 50 |     server_parser = subparsers.add_parser(
 51 |         'server',
 52 |         help='Run MCP server'
 53 |     )
 54 |     server_parser.add_argument(
 55 |         "--log-level",
 56 |         choices=["DEBUG", "INFO", "WARNING", "ERROR"],
 57 |         default="INFO",
 58 |         help="Set the logging level",
 59 |     )
 60 |     server_parser.add_argument(
 61 |         "--version",
 62 |         action="version",
 63 |         version="MCP Server v1.0.0",
 64 |     )
 65 |     
 66 |     # Client subcommand
 67 |     client_parser = subparsers.add_parser(
 68 |         'client',
 69 |         help='Run MCP client'
 70 |     )
 71 |     
 72 |     # GUI subcommand
 73 |     gui_parser = subparsers.add_parser(
 74 |         'gui',
 75 |         help='Launch Streamlit GUI'
 76 |     )
 77 |     gui_parser.add_argument(
 78 |         "--log-level",
 79 |         choices=["DEBUG", "INFO", "WARNING", "ERROR"],
 80 |         default="INFO",
 81 |         help="Set the logging level",
 82 |     )
 83 |     gui_parser.add_argument(
 84 |         "--port",
 85 |         type=int,
 86 |         default=8501,
 87 |         help="Port for Streamlit server (default: 8501)",
 88 |     )
 89 |     client_parser.add_argument(
 90 |         '--server',
 91 |         required=True,
 92 |         help='Path to MCP server script'
 93 |     )
 94 |     client_parser.add_argument(
 95 |         '--log-level',
 96 |         choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
 97 |         default='INFO',
 98 |         help='Set logging level (default: INFO)'
 99 |     )
100 |     client_parser.add_argument(
101 |         '--timeout',
102 |         type=int,
103 |         default=30,
104 |         help='Connection timeout in seconds (default: 30)'
105 |     )
106 |     
107 |     # Tool subcommands for client
108 |     tool_subparsers = client_parser.add_subparsers(
109 |         dest='tool',
110 |         help='Available tools',
111 |         metavar='TOOL'
112 |     )
113 |     
114 |     # Roll dice tool
115 |     dice_parser = tool_subparsers.add_parser(
116 |         'roll_dice',
117 |         help='Roll dice using standard notation'
118 |     )
119 |     dice_parser.add_argument(
120 |         '--notation',
121 |         required=True,
122 |         help='Dice notation (e.g., 2d6, 1d20, 3d10)'
123 |     )
124 |     
125 |     # Weather tool
126 |     weather_parser = tool_subparsers.add_parser(
127 |         'get_weather',
128 |         help='Get current weather conditions'
129 |     )
130 |     weather_parser.add_argument(
131 |         '--location',
132 |         required=True,
133 |         help='Location name or coordinates (lat,lon)'
134 |     )
135 |     
136 |     # Date/time tool
137 |     date_parser = tool_subparsers.add_parser(
138 |         'get_date',
139 |         help='Get current date and time'
140 |     )
141 |     date_parser.add_argument(
142 |         '--timezone',
143 |         default='UTC',
144 |         help='Timezone identifier (default: UTC)'
145 |     )
146 | 
147 |     args = parser.parse_args()
148 | 
149 |     # Check if mode is specified
150 |     if not args.mode:
151 |         parser.print_help()
152 |         sys.exit(1)
153 | 
154 |     # Setup logging
155 |     log_level = getattr(args, 'log_level', 'INFO')
156 |     setup_logging(log_level)
157 | 
158 |     logger = logging.getLogger(__name__)
159 | 
160 |     try:
161 |         if args.mode == 'server':
162 |             logger.info("Starting MCP Server application")
163 |             # Run the MCP server (this will block until server shuts down)
164 |             run_server()
165 |         elif args.mode == 'client':
166 |             logger.info("Starting MCP Client application")
167 |             # Create client CLI and run it
168 |             cli = MCPClientCLI()
169 |             
170 |             # Build client arguments from parsed args
171 |             client_args = [
172 |                 '--server', args.server,
173 |                 '--log-level', args.log_level,
174 |                 '--timeout', str(args.timeout)
175 |             ]
176 |             
177 |             if args.tool:
178 |                 client_args.append(args.tool)
179 |                 
180 |                 # Add tool-specific arguments
181 |                 if args.tool == 'roll_dice':
182 |                     client_args.extend(['--notation', args.notation])
183 |                 elif args.tool == 'get_weather':
184 |                     client_args.extend(['--location', args.location])
185 |                 elif args.tool == 'get_date':
186 |                     client_args.extend(['--timezone', args.timezone])
187 |             
188 |             # Run the client
189 |             exit_code = await cli.run(client_args)
190 |             sys.exit(exit_code)
191 |         elif args.mode == 'gui':
192 |             logger.info("Starting Streamlit GUI application")
193 |             # Launch Streamlit GUI
194 |             import os
195 |             import subprocess
196 |             
197 |             # Set environment variables for Streamlit
198 |             env = os.environ.copy()
199 |             env['STREAMLIT_SERVER_PORT'] = str(args.port)
200 |             env['STREAMLIT_LOGGER_LEVEL'] = args.log_level
201 |             
202 |             # Run Streamlit
203 |             cmd = [
204 |                 'streamlit', 'run', 
205 |                 'src/gui/app.py',
206 |                 '--server.port', str(args.port),
207 |                 '--logger.level', args.log_level.lower()
208 |             ]
209 |             
210 |             subprocess.run(cmd, env=env)
211 |         else:
212 |             parser.print_help()
213 |             sys.exit(1)
214 |             
215 |     except KeyboardInterrupt:
216 |         logger.info("Application interrupted by user")
217 |         sys.exit(0)
218 |     except Exception as e:
219 |         logger.error(f"Application error: {e}")
220 |         sys.exit(1)
221 | 
222 | 
223 | if __name__ == "__main__":
224 |     run(main())
225 | 


--------------------------------------------------------------------------------
/src/mcp_client/__init__.py:
--------------------------------------------------------------------------------
1 | """MCP Client implementation for tool invocation."""
2 | 
3 | from .cli import MCPClientCLI
4 | from .client import MCPClient
5 | 
6 | __all__ = ["MCPClient", "MCPClientCLI"]
7 | 


--------------------------------------------------------------------------------
/src/mcp_client/cli.py:
--------------------------------------------------------------------------------
  1 | """CLI interface for MCP client tool invocation."""
  2 | 
  3 | import argparse
  4 | import asyncio
  5 | import json
  6 | import logging
  7 | import sys
  8 | from typing import Any
  9 | 
 10 | from .client import MCPClient
 11 | from .models.responses import ClientToolResult
 12 | 
 13 | # Configure logging
 14 | logger = logging.getLogger(__name__)
 15 | 
 16 | 
 17 | class MCPClientCLI:
 18 |     """CLI interface for MCP client tool invocation."""
 19 | 
 20 |     def __init__(self) -> None:
 21 |         """Initialize CLI interface."""
 22 |         self.parser = self._create_parser()
 23 |         self.client: MCPClient | None = None
 24 | 
 25 |     def _create_parser(self) -> argparse.ArgumentParser:
 26 |         """Create argument parser with subcommands.
 27 |         
 28 |         Returns:
 29 |             Configured argument parser
 30 |         """
 31 |         parser = argparse.ArgumentParser(
 32 |             description="MCP Client for tool invocation",
 33 |             formatter_class=argparse.RawDescriptionHelpFormatter,
 34 |             epilog="""Examples:
 35 |   %(prog)s --server ./server.py roll_dice --notation 2d6
 36 |   %(prog)s --server ./server.py get_weather --location "San Francisco"
 37 |   %(prog)s --server ./server.py get_date --timezone UTC
 38 | """
 39 |         )
 40 |         
 41 |         # Global arguments
 42 |         parser.add_argument(
 43 |             '--server',
 44 |             required=True,
 45 |             help='Path to MCP server script'
 46 |         )
 47 |         
 48 |         parser.add_argument(
 49 |             '--log-level',
 50 |             choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
 51 |             default='INFO',
 52 |             help='Set logging level (default: INFO)'
 53 |         )
 54 |         
 55 |         parser.add_argument(
 56 |             '--timeout',
 57 |             type=int,
 58 |             default=30,
 59 |             help='Connection timeout in seconds (default: 30)'
 60 |         )
 61 |         
 62 |         # Subcommands for tools
 63 |         subparsers = parser.add_subparsers(
 64 |             dest='tool',
 65 |             help='Available tools',
 66 |             metavar='TOOL'
 67 |         )
 68 |         
 69 |         # Roll dice tool
 70 |         dice_parser = subparsers.add_parser(
 71 |             'roll_dice',
 72 |             help='Roll dice using standard notation'
 73 |         )
 74 |         dice_parser.add_argument(
 75 |             '--notation',
 76 |             required=True,
 77 |             help='Dice notation (e.g., 2d6, 1d20, 3d10)'
 78 |         )
 79 |         
 80 |         # Weather tool
 81 |         weather_parser = subparsers.add_parser(
 82 |             'get_weather',
 83 |             help='Get current weather conditions'
 84 |         )
 85 |         weather_parser.add_argument(
 86 |             '--location',
 87 |             required=True,
 88 |             help='Location name or coordinates (lat,lon)'
 89 |         )
 90 |         
 91 |         # Date/time tool
 92 |         date_parser = subparsers.add_parser(
 93 |             'get_date',
 94 |             help='Get current date and time'
 95 |         )
 96 |         date_parser.add_argument(
 97 |             '--timezone',
 98 |             default='UTC',
 99 |             help='Timezone identifier (default: UTC)'
100 |         )
101 |         
102 |         return parser
103 | 
104 |     def _setup_logging(self, level: str) -> None:
105 |         """Setup logging configuration.
106 |         
107 |         Args:
108 |             level: Logging level string
109 |         """
110 |         logging.basicConfig(
111 |             level=getattr(logging, level.upper()),
112 |             format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
113 |             datefmt='%Y-%m-%d %H:%M:%S'
114 |         )
115 | 
116 |     def _build_tool_arguments(self, args: argparse.Namespace) -> dict[str, Any]:
117 |         """Build tool arguments from parsed CLI arguments.
118 |         
119 |         Args:
120 |             args: Parsed command line arguments
121 |             
122 |         Returns:
123 |             Dictionary of tool arguments
124 |         """
125 |         if args.tool == 'roll_dice':
126 |             return {'notation': args.notation}
127 |         elif args.tool == 'get_weather':
128 |             return {'location': args.location}
129 |         elif args.tool == 'get_date':
130 |             return {'timezone': args.timezone}
131 |         else:
132 |             return {}
133 | 
134 |     def _display_success(self, result: ClientToolResult) -> None:
135 |         """Display successful tool result.
136 |         
137 |         Args:
138 |             result: Successful tool result
139 |         """
140 |         print(f"✅ {result.tool_name} executed successfully:")
141 |         print()
142 |         
143 |         # Handle MCP response format
144 |         if result.result and hasattr(result.result, 'content'):
145 |             content = result.result.content
146 |             if isinstance(content, list):
147 |                 for item in content:
148 |                     if isinstance(item, dict) and 'text' in item:
149 |                         print(item['text'])
150 |                     else:
151 |                         print(json.dumps(item, indent=2))
152 |             else:
153 |                 print(json.dumps(content, indent=2))
154 |         else:
155 |             print(json.dumps(result.result, indent=2))
156 | 
157 |     def _display_error(self, result: ClientToolResult) -> None:
158 |         """Display tool execution error.
159 |         
160 |         Args:
161 |             result: Failed tool result
162 |         """
163 |         print(f"❌ {result.tool_name} failed:")
164 |         print(f"Error: {result.error}")
165 |         print()
166 |         print(f"Tool: {result.tool_name}")
167 |         print(f"Arguments: {json.dumps(result.arguments, indent=2)}")
168 | 
169 |     def _display_connection_error(self, error: Exception) -> None:
170 |         """Display connection error.
171 |         
172 |         Args:
173 |             error: Connection error
174 |         """
175 |         print("❌ Connection failed:")
176 |         print(f"Error: {error}")
177 |         print()
178 |         print("Troubleshooting:")
179 |         print("1. Check that the server script exists")
180 |         print("2. Verify the server script is executable")
181 |         print("3. Ensure required dependencies are installed")
182 |         print("4. Check that the server starts correctly")
183 | 
184 |     async def run(self, args: list[str] | None = None) -> int:
185 |         """Run CLI with provided arguments.
186 |         
187 |         Args:
188 |             args: Command line arguments (uses sys.argv if None)
189 |             
190 |         Returns:
191 |             Exit code (0 for success, 1 for error)
192 |         """
193 |         try:
194 |             # Parse arguments
195 |             parsed_args = self.parser.parse_args(args)
196 |             
197 |             # Setup logging
198 |             self._setup_logging(parsed_args.log_level)
199 |             
200 |             # Check if tool specified
201 |             if not parsed_args.tool:
202 |                 self.parser.print_help()
203 |                 return 1
204 |             
205 |             # Create client
206 |             self.client = MCPClient(parsed_args.server)
207 |             
208 |             # Connect to server with timeout
209 |             try:
210 |                 await asyncio.wait_for(
211 |                     self.client.connect(),
212 |                     timeout=parsed_args.timeout
213 |                 )
214 |             except TimeoutError:
215 |                 print(f"❌ Connection timeout after {parsed_args.timeout} seconds")
216 |                 return 1
217 |             except Exception as e:
218 |                 self._display_connection_error(e)
219 |                 return 1
220 |             
221 |             # Build tool arguments
222 |             tool_args = self._build_tool_arguments(parsed_args)
223 |             
224 |             # Invoke tool
225 |             result = await self.client.invoke_tool(parsed_args.tool, tool_args)
226 |             
227 |             # Display result
228 |             if result.success:
229 |                 self._display_success(result)
230 |                 return 0
231 |             else:
232 |                 self._display_error(result)
233 |                 return 1
234 |                 
235 |         except KeyboardInterrupt:
236 |             print("\n❌ Interrupted by user")
237 |             return 130
238 |         except Exception as e:
239 |             logger.error(f"Unexpected error: {e}")
240 |             print(f"❌ Unexpected error: {e}")
241 |             return 1
242 |         finally:
243 |             # Cleanup
244 |             if self.client:
245 |                 await self.client.disconnect()
246 | 
247 | 
248 | async def main() -> int:
249 |     """Main CLI entry point.
250 |     
251 |     Returns:
252 |         Exit code
253 |     """
254 |     cli = MCPClientCLI()
255 |     return await cli.run()
256 | 
257 | 
258 | if __name__ == '__main__':
259 |     sys.exit(asyncio.run(main()))
260 | 


--------------------------------------------------------------------------------
/src/mcp_client/client.py:
--------------------------------------------------------------------------------
  1 | """Main MCP client class for tool invocation."""
  2 | 
  3 | import logging
  4 | from typing import Any
  5 | 
  6 | from .models.responses import ClientToolResult
  7 | from .transport import MCPTransport
  8 | 
  9 | # Configure logging
 10 | logger = logging.getLogger(__name__)
 11 | 
 12 | 
 13 | class MCPClient:
 14 |     """MCP client for connecting to servers and invoking tools."""
 15 | 
 16 |     def __init__(self, server_path: str):
 17 |         """Initialize MCP client.
 18 |         
 19 |         Args:
 20 |             server_path: Path to the MCP server script
 21 |         """
 22 |         self.server_path = server_path
 23 |         self.transport = MCPTransport(server_path)
 24 |         self._connected = False
 25 | 
 26 |     @property
 27 |     def connected(self) -> bool:
 28 |         """Check if client is connected to server."""
 29 |         return self._connected and self.transport.connected
 30 | 
 31 |     @property
 32 |     def available_tools(self) -> list[str]:
 33 |         """Get list of available tools."""
 34 |         return self.transport.available_tools
 35 | 
 36 |     async def connect(self) -> None:
 37 |         """Connect to MCP server.
 38 |         
 39 |         Raises:
 40 |             FileNotFoundError: If server script doesn't exist
 41 |             ConnectionError: If connection fails
 42 |             ValueError: If server script type is not supported
 43 |         """
 44 |         logger.info(f"Connecting to MCP server: {self.server_path}")
 45 |         
 46 |         try:
 47 |             await self.transport.connect()
 48 |             self._connected = True
 49 |             logger.info(
 50 |                 f"Connected successfully. Available tools: {self.available_tools}"
 51 |             )
 52 |         except Exception as e:
 53 |             logger.error(f"Failed to connect: {e}")
 54 |             raise
 55 | 
 56 |     async def disconnect(self) -> None:
 57 |         """Disconnect from MCP server."""
 58 |         logger.info("Disconnecting from MCP server")
 59 |         await self.transport.disconnect()
 60 |         self._connected = False
 61 | 
 62 |     async def invoke_tool(
 63 |         self, tool_name: str, arguments: dict[str, Any]
 64 |     ) -> ClientToolResult:
 65 |         """Invoke a tool on the connected server.
 66 |         
 67 |         Args:
 68 |             tool_name: Name of the tool to invoke
 69 |             arguments: Arguments to pass to the tool
 70 |             
 71 |         Returns:
 72 |             ClientToolResult with success status and result or error
 73 |         """
 74 |         logger.info(f"Invoking tool: {tool_name} with arguments: {arguments}")
 75 |         
 76 |         # Check if connected
 77 |         if not self.connected:
 78 |             error_msg = "Not connected to server"
 79 |             logger.error(error_msg)
 80 |             return ClientToolResult(
 81 |                 success=False,
 82 |                 result=None,
 83 |                 error=error_msg,
 84 |                 tool_name=tool_name,
 85 |                 arguments=arguments
 86 |             )
 87 |         
 88 |         # Check if tool is available
 89 |         if tool_name not in self.available_tools:
 90 |             error_msg = (
 91 |                 f"Tool '{tool_name}' not available. "
 92 |                 f"Available tools: {self.available_tools}"
 93 |             )
 94 |             logger.error(error_msg)
 95 |             return ClientToolResult(
 96 |                 success=False,
 97 |                 result=None,
 98 |                 error=error_msg,
 99 |                 tool_name=tool_name,
100 |                 arguments=arguments
101 |             )
102 |         
103 |         try:
104 |             # Call the tool through transport
105 |             result = await self.transport.call_tool(tool_name, arguments)
106 |             
107 |             # Process the result
108 |             logger.info(f"Tool '{tool_name}' executed successfully")
109 |             return ClientToolResult(
110 |                 success=True,
111 |                 result=result,
112 |                 error=None,
113 |                 tool_name=tool_name,
114 |                 arguments=arguments
115 |             )
116 |             
117 |         except Exception as e:
118 |             error_msg = f"Tool execution failed: {str(e)}"
119 |             logger.error(error_msg)
120 |             return ClientToolResult(
121 |                 success=False,
122 |                 result=None,
123 |                 error=error_msg,
124 |                 tool_name=tool_name,
125 |                 arguments=arguments
126 |             )
127 | 
128 |     async def health_check(self) -> bool:
129 |         """Check if connection is healthy.
130 |         
131 |         Returns:
132 |             True if connection is healthy, False otherwise
133 |         """
134 |         if not self.connected:
135 |             return False
136 |         
137 |         return await self.transport.health_check()
138 | 
139 |     async def __aenter__(self) -> "MCPClient":
140 |         """Async context manager entry."""
141 |         await self.connect()
142 |         return self
143 | 
144 |     async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
145 |         """Async context manager exit."""
146 |         await self.disconnect()
147 | 
148 | 
149 | class MCPClientError(Exception):
150 |     """Base exception for MCP client errors."""
151 |     pass
152 | 
153 | 
154 | class MCPConnectionError(MCPClientError):
155 |     """Raised when connection to MCP server fails."""
156 |     pass
157 | 
158 | 
159 | class MCPToolError(MCPClientError):
160 |     """Raised when tool execution fails."""
161 |     pass
162 | 


--------------------------------------------------------------------------------
/src/mcp_client/models/__init__.py:
--------------------------------------------------------------------------------
1 | """MCP Client models for type safety and validation."""
2 | 
3 | from .responses import ClientToolResult, MCPToolResponse
4 | 
5 | __all__ = ["ClientToolResult", "MCPToolResponse"]
6 | 


--------------------------------------------------------------------------------
/src/mcp_client/models/responses.py:
--------------------------------------------------------------------------------
 1 | """Client-specific response models for MCP tool invocation."""
 2 | 
 3 | from typing import Any
 4 | 
 5 | from pydantic import BaseModel, Field
 6 | 
 7 | 
 8 | class MCPToolResponse(BaseModel):
 9 |     """Response from MCP tool execution."""
10 | 
11 |     content: list[dict[str, Any]] = Field(..., description="Response content")
12 |     isError: bool = Field(False, description="Whether response indicates error")
13 | 
14 | 
15 | class ClientToolResult(BaseModel):
16 |     """Processed tool result for client consumption."""
17 | 
18 |     success: bool = Field(..., description="Whether tool execution was successful")
19 |     result: Any | None = Field(None, description="Tool execution result")
20 |     error: str | None = Field(None, description="Error message if execution failed")
21 |     tool_name: str = Field(..., description="Name of the tool that was executed")
22 |     arguments: dict[str, Any] = Field(..., description="Arguments passed to the tool")
23 | 
24 | 
25 | class ClientSession(BaseModel):
26 |     """Client session information."""
27 | 
28 |     server_path: str = Field(..., description="Path to the MCP server script")
29 |     connected: bool = Field(False, description="Whether client is connected to server")
30 |     available_tools: list[str] = Field(
31 |         default_factory=list, description="List of available tools"
32 |     )
33 | 


--------------------------------------------------------------------------------
/src/mcp_client/transport.py:
--------------------------------------------------------------------------------
  1 | """Transport layer for MCP client connections."""
  2 | 
  3 | import os
  4 | from contextlib import AsyncExitStack
  5 | from typing import Any
  6 | 
  7 | from mcp import ClientSession, StdioServerParameters
  8 | from mcp.client.stdio import stdio_client
  9 | 
 10 | 
 11 | class MCPTransport:
 12 |     """Handles MCP server connections via stdio transport."""
 13 | 
 14 |     def __init__(self, server_path: str):
 15 |         """Initialize transport with server path.
 16 |         
 17 |         Args:
 18 |             server_path: Path to the MCP server script
 19 |         """
 20 |         self.server_path = server_path
 21 |         self.session: ClientSession | None = None
 22 |         self.exit_stack: AsyncExitStack | None = None
 23 |         self.connected = False
 24 |         self.available_tools: list[str] = []
 25 | 
 26 |     async def connect(self) -> None:
 27 |         """Connect to MCP server via stdio transport.
 28 |         
 29 |         Raises:
 30 |             FileNotFoundError: If server script doesn't exist
 31 |             ConnectionError: If connection fails
 32 |             ValueError: If server script type is not supported
 33 |         """
 34 |         # Validate server script exists
 35 |         if not os.path.exists(self.server_path):
 36 |             raise FileNotFoundError(f"Server script not found: {self.server_path}")
 37 |         
 38 |         # Determine server type and command
 39 |         if self.server_path.endswith('.py'):
 40 |             command = "python"
 41 |         elif self.server_path.endswith('.js'):
 42 |             command = "node"
 43 |         else:
 44 |             raise ValueError(f"Unsupported server script type: {self.server_path}")
 45 |         
 46 |         # Create server parameters
 47 |         server_params = StdioServerParameters(
 48 |             command=command,
 49 |             args=[self.server_path],
 50 |             env=None
 51 |         )
 52 |         
 53 |         try:
 54 |             # Setup resource management
 55 |             self.exit_stack = AsyncExitStack()
 56 |             
 57 |             # Connect to server
 58 |             read, write = await self.exit_stack.enter_async_context(
 59 |                 stdio_client(server_params)
 60 |             )
 61 |             
 62 |             # Create session
 63 |             self.session = await self.exit_stack.enter_async_context(
 64 |                 ClientSession(read, write)
 65 |             )
 66 |             
 67 |             # Initialize connection
 68 |             await self.session.initialize()
 69 |             
 70 |             # Discover available tools
 71 |             tools_response = await self.session.list_tools()
 72 |             self.available_tools = [tool.name for tool in tools_response.tools]
 73 |             
 74 |             self.connected = True
 75 |             
 76 |         except Exception as e:
 77 |             # Clean up on connection failure
 78 |             if self.exit_stack:
 79 |                 await self.exit_stack.aclose()
 80 |                 self.exit_stack = None
 81 |             raise ConnectionError(f"Failed to connect to server: {e}")
 82 | 
 83 |     async def disconnect(self) -> None:
 84 |         """Disconnect from MCP server."""
 85 |         if self.exit_stack:
 86 |             await self.exit_stack.aclose()
 87 |             self.exit_stack = None
 88 |         
 89 |         self.session = None
 90 |         self.connected = False
 91 |         self.available_tools = []
 92 | 
 93 |     async def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
 94 |         """Call a tool on the connected server.
 95 |         
 96 |         Args:
 97 |             tool_name: Name of the tool to call
 98 |             arguments: Arguments to pass to the tool
 99 |             
100 |         Returns:
101 |             Tool response content
102 |             
103 |         Raises:
104 |             RuntimeError: If not connected to server
105 |             ValueError: If tool is not available
106 |         """
107 |         if not self.connected or not self.session:
108 |             raise RuntimeError("Not connected to server")
109 |         
110 |         if tool_name not in self.available_tools:
111 |             raise ValueError(
112 |                 f"Tool '{tool_name}' not available. "
113 |                 f"Available tools: {self.available_tools}"
114 |             )
115 |         
116 |         # Call the tool
117 |         result = await self.session.call_tool(tool_name, arguments)
118 |         return result
119 | 
120 |     async def health_check(self) -> bool:
121 |         """Check if connection is healthy.
122 |         
123 |         Returns:
124 |             True if connection is healthy, False otherwise
125 |         """
126 |         if not self.connected or not self.session:
127 |             return False
128 |         
129 |         try:
130 |             # Try to list tools as a health check
131 |             await self.session.list_tools()
132 |             return True
133 |         except Exception:
134 |             return False
135 | 
136 |     async def __aenter__(self) -> "MCPTransport":
137 |         """Async context manager entry."""
138 |         await self.connect()
139 |         return self
140 | 
141 |     async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
142 |         """Async context manager exit."""
143 |         await self.disconnect()
144 | 


--------------------------------------------------------------------------------
/src/mcp_server/__init__.py:
--------------------------------------------------------------------------------
1 | """MCP server package."""
2 | 
3 | from .server import mcp, run_server
4 | 
5 | __all__ = ["mcp", "run_server"]


--------------------------------------------------------------------------------
/src/mcp_server/models/__init__.py:
--------------------------------------------------------------------------------
 1 | """MCP server data models."""
 2 | 
 3 | from .requests import (
 4 |     DateTimeRequest,
 5 |     DateTimeResponse,
 6 |     DiceRollRequest,
 7 |     DiceRollResponse,
 8 |     MCPError,
 9 |     MCPRequest,
10 |     MCPResponse,
11 |     ToolCallRequest,
12 |     ToolCallResponse,
13 |     WeatherRequest,
14 |     WeatherResponse,
15 | )
16 | 
17 | __all__ = [
18 |     "DateTimeRequest",
19 |     "DateTimeResponse",
20 |     "DiceRollRequest",
21 |     "DiceRollResponse",
22 |     "MCPError",
23 |     "MCPRequest",
24 |     "MCPResponse",
25 |     "ToolCallRequest",
26 |     "ToolCallResponse",
27 |     "WeatherRequest",
28 |     "WeatherResponse",
29 | ]


--------------------------------------------------------------------------------
/src/mcp_server/models/requests.py:
--------------------------------------------------------------------------------
  1 | """Pydantic models for MCP server request/response validation."""
  2 | 
  3 | import re
  4 | from typing import Any
  5 | 
  6 | from pydantic import BaseModel, Field, field_validator
  7 | 
  8 | 
  9 | class MCPRequest(BaseModel):
 10 |     """Base MCP request structure following JSON-RPC 2.0 format."""
 11 | 
 12 |     jsonrpc: str = "2.0"
 13 |     method: str
 14 |     params: dict | None = None
 15 |     id: str | int | None = None
 16 | 
 17 | 
 18 | class MCPResponse(BaseModel):
 19 |     """Base MCP response structure following JSON-RPC 2.0 format."""
 20 | 
 21 |     jsonrpc: str = "2.0"
 22 |     id: str | int | None = None
 23 |     result: Any | None = None
 24 |     error: dict | None = None
 25 | 
 26 | 
 27 | class MCPError(BaseModel):
 28 |     """MCP error structure."""
 29 | 
 30 |     code: int
 31 |     message: str
 32 |     data: dict | None = None
 33 | 
 34 | 
 35 | class DiceRollRequest(BaseModel):
 36 |     """Dice roll tool request with notation validation."""
 37 | 
 38 |     notation: str = Field(..., description="Dice notation like '2d6' or '1d20'")
 39 | 
 40 |     @field_validator("notation")
 41 |     @classmethod
 42 |     def validate_notation(cls, v: str) -> str:
 43 |         """Validate dice notation format."""
 44 |         if not isinstance(v, str):
 45 |             raise ValueError("Notation must be a string")
 46 | 
 47 |         # Remove spaces and convert to lowercase
 48 |         notation = v.strip().lower()
 49 | 
 50 |         # Validate format using regex
 51 |         pattern = re.compile(r"^(\d+)d(\d+)

quot;)
 52 |         match = pattern.match(notation)
 53 | 
 54 |         if not match:
 55 |             raise ValueError(
 56 |                 f"Invalid dice notation: '{v}'. "
 57 |                 f"Expected format: 'XdY' (e.g., '2d6', '1d20')"
 58 |             )
 59 | 
 60 |         dice_count = int(match.group(1))
 61 |         sides = int(match.group(2))
 62 | 
 63 |         # Validate reasonable limits
 64 |         if dice_count <= 0:
 65 |             raise ValueError("Dice count must be greater than 0")
 66 |         if dice_count > 100:
 67 |             raise ValueError("Dice count must not exceed 100")
 68 | 
 69 |         if sides <= 0:
 70 |             raise ValueError("Number of sides must be greater than 0")
 71 |         if sides > 1000:
 72 |             raise ValueError("Number of sides must not exceed 1000")
 73 | 
 74 |         return notation
 75 | 
 76 | 
 77 | class DiceRollResponse(BaseModel):
 78 |     """Dice roll tool response."""
 79 | 
 80 |     values: list[int] = Field(..., description="Individual dice roll results")
 81 |     total: int = Field(..., description="Sum of all dice rolls")
 82 |     notation: str = Field(..., description="Original dice notation")
 83 | 
 84 | 
 85 | class WeatherRequest(BaseModel):
 86 |     """Weather tool request with location validation."""
 87 | 
 88 |     location: str = Field(..., description="City name or coordinates (lat,lon)")
 89 | 
 90 |     @field_validator("location")
 91 |     @classmethod
 92 |     def validate_location(cls, v: str) -> str:
 93 |         """Validate location format."""
 94 |         if not isinstance(v, str):
 95 |             raise ValueError("Location must be a string")
 96 | 
 97 |         location = v.strip()
 98 |         if not location:
 99 |             raise ValueError("Location cannot be empty")
100 | 
101 |         return location
102 | 
103 | 
104 | class WeatherResponse(BaseModel):
105 |     """Weather tool response."""
106 | 
107 |     location: str = Field(..., description="Requested location")
108 |     temperature: float = Field(..., description="Temperature in Celsius")
109 |     condition: str = Field(..., description="Weather condition description")
110 |     wind_speed: float = Field(..., description="Wind speed in km/h")
111 |     humidity: float | None = Field(None, description="Humidity percentage")
112 |     timestamp: str | None = Field(None, description="Data timestamp")
113 | 
114 | 
115 | class DateTimeRequest(BaseModel):
116 |     """Date/time tool request with timezone validation."""
117 | 
118 |     timezone: str = Field(
119 |         "UTC", description="Timezone identifier (e.g., 'UTC', 'America/New_York')"
120 |     )
121 | 
122 |     @field_validator("timezone")
123 |     @classmethod
124 |     def validate_timezone(cls, v: str) -> str:
125 |         """Validate timezone format."""
126 |         if not isinstance(v, str):
127 |             raise ValueError("Timezone must be a string")
128 | 
129 |         timezone = v.strip()
130 |         if not timezone:
131 |             raise ValueError("Timezone cannot be empty")
132 | 
133 |         return timezone
134 | 
135 | 
136 | class DateTimeResponse(BaseModel):
137 |     """Date/time tool response."""
138 | 
139 |     datetime: str = Field(..., description="ISO 8601 formatted date/time")
140 |     timezone: str = Field(..., description="Timezone identifier")
141 |     timestamp: float = Field(..., description="Unix timestamp")
142 | 
143 | 
144 | class ToolCallRequest(BaseModel):
145 |     """Generic tool call request."""
146 | 
147 |     name: str = Field(..., description="Tool name")
148 |     arguments: dict = Field(..., description="Tool arguments")
149 | 
150 | 
151 | class ToolCallResponse(BaseModel):
152 |     """Generic tool call response."""
153 | 
154 |     content: list[dict] = Field(..., description="Tool response content")
155 |     isError: bool = Field(False, description="Whether this is an error response")


--------------------------------------------------------------------------------
/src/mcp_server/server.py:
--------------------------------------------------------------------------------
  1 | """MCP server implementation with dice, weather, and date/time tools."""
  2 | 
  3 | import logging
  4 | from typing import Any
  5 | 
  6 | from mcp.server.fastmcp import FastMCP
  7 | 
  8 | from .tools.date_time import DateTimeTool
  9 | from .tools.dice import DiceRollTool
 10 | from .tools.weather import WeatherTool
 11 | 
 12 | # Configure logging
 13 | logging.basicConfig(level=logging.INFO)
 14 | logger = logging.getLogger(__name__)
 15 | 
 16 | # Create MCP server instance
 17 | mcp = FastMCP("dice-weather-datetime-server")
 18 | 
 19 | # Initialize tool instances
 20 | dice_tool = DiceRollTool()
 21 | weather_tool = WeatherTool()
 22 | datetime_tool = DateTimeTool()
 23 | 
 24 | 
 25 | @mcp.tool()
 26 | async def roll_dice(notation: str) -> dict[str, Any]:
 27 |     """Roll dice using standard notation like '2d6' or '1d20'.
 28 | 
 29 |     Args:
 30 |         notation: Dice notation (e.g., "2d6", "1d20", "3d10")
 31 | 
 32 |     Returns:
 33 |         Dict containing dice roll results, total, and formatted display
 34 |     """
 35 |     logger.info(f"Tool call: roll_dice(notation='{notation}')")
 36 |     return await dice_tool.safe_execute(notation=notation)
 37 | 
 38 | 
 39 | @mcp.tool()
 40 | async def get_weather(location: str) -> dict[str, Any]:
 41 |     """Get current weather conditions for a location.
 42 | 
 43 |     Args:
 44 |         location: City name or coordinates (lat,lon)
 45 | 
 46 |     Returns:
 47 |         Dict containing weather data including temperature, condition, and wind speed
 48 |     """
 49 |     logger.info(f"Tool call: get_weather(location='{location}')")
 50 |     return await weather_tool.safe_execute(location=location)
 51 | 
 52 | 
 53 | @mcp.tool()
 54 | async def get_date(timezone: str = "UTC") -> dict[str, Any]:
 55 |     """Get current date and time for a specific timezone.
 56 | 
 57 |     Args:
 58 |         timezone: Timezone identifier (e.g., "UTC", "America/New_York") or alias
 59 | 
 60 |     Returns:
 61 |         Dict containing current date/time in ISO 8601 format with timezone info
 62 |     """
 63 |     logger.info(f"Tool call: get_date(timezone='{timezone}')")
 64 |     return await datetime_tool.safe_execute(timezone=timezone)
 65 | 
 66 | 
 67 | @mcp.resource("mcp://tools/help")
 68 | async def get_help() -> str:
 69 |     """Get help information about available tools."""
 70 |     help_text = """
 71 | 🎲 **MCP Server - Available Tools**
 72 | 
 73 | **roll_dice** - Roll dice using standard notation
 74 | - Usage: roll_dice(notation="2d6")
 75 | - Examples: "1d20", "3d6", "2d10"
 76 | - Returns individual values and total
 77 | 
 78 | **get_weather** - Get current weather conditions  
 79 | - Usage: get_weather(location="San Francisco")
 80 | - Supports city names or coordinates (lat,lon)
 81 | - Returns temperature, condition, wind speed
 82 | 
 83 | **get_date** - Get current date and time
 84 | - Usage: get_date(timezone="UTC")
 85 | - Supports IANA timezones and common aliases
 86 | - Returns ISO 8601 formatted datetime
 87 | 
 88 | **Examples:**
 89 | - roll_dice("2d6") → Roll two six-sided dice
 90 | - get_weather("London") → Weather for London
 91 | - get_date("America/New_York") → NYC current time
 92 | """
 93 |     return help_text
 94 | 
 95 | 
 96 | async def cleanup_server():
 97 |     """Cleanup server resources."""
 98 |     logger.info("Cleaning up server resources...")
 99 |     try:
100 |         await weather_tool.cleanup()
101 |         logger.info("Server cleanup completed")
102 |     except Exception as e:
103 |         logger.error(f"Error during cleanup: {e}")
104 | 
105 | 
106 | # Server lifecycle management
107 | async def startup():
108 |     """Server startup handler."""
109 |     logger.info("MCP Server starting up...")
110 |     logger.info("Tools available: roll_dice, get_weather, get_date")
111 | 
112 | 
113 | async def shutdown():
114 |     """Server shutdown handler."""
115 |     logger.info("MCP Server shutting down...")
116 |     await cleanup_server()
117 | 
118 | 
119 | def run_server():
120 |     """Run the MCP server."""
121 |     try:
122 |         logger.info("Starting MCP server...")
123 |         mcp.run()
124 |     except KeyboardInterrupt:
125 |         logger.info("Server interrupted by user")
126 |     except Exception as e:
127 |         logger.error(f"Server error: {e}")
128 |         raise
129 | 
130 | 
131 | if __name__ == "__main__":
132 |     run_server()


--------------------------------------------------------------------------------
/src/mcp_server/tools/__init__.py:
--------------------------------------------------------------------------------
 1 | """MCP server tools package."""
 2 | 
 3 | from .base import (
 4 |     AsyncHttpMixin,
 5 |     BaseTool,
 6 |     ExternalServiceError,
 7 |     ToolError,
 8 |     ValidationToolError,
 9 | )
10 | 
11 | __all__ = [
12 |     "AsyncHttpMixin",
13 |     "BaseTool",
14 |     "ExternalServiceError",
15 |     "ToolError",
16 |     "ValidationToolError",
17 | ]


--------------------------------------------------------------------------------
/src/mcp_server/tools/base.py:
--------------------------------------------------------------------------------
  1 | """Base tool interface and common patterns for MCP server tools."""
  2 | 
  3 | import logging
  4 | from abc import ABC, abstractmethod
  5 | from typing import Any
  6 | 
  7 | import httpx
  8 | from pydantic import BaseModel, ValidationError
  9 | 
 10 | logger = logging.getLogger(__name__)
 11 | 
 12 | 
 13 | class ToolError(Exception):
 14 |     """Base exception for tool-related errors."""
 15 | 
 16 |     def __init__(
 17 |         self, message: str, code: int = -1, data: dict[str, Any] | None = None
 18 |     ):
 19 |         super().__init__(message)
 20 |         self.message = message
 21 |         self.code = code
 22 |         self.data = data or {}
 23 | 
 24 | 
 25 | class ValidationToolError(ToolError):
 26 |     """Exception for input validation errors."""
 27 | 
 28 |     def __init__(self, message: str, validation_errors: list | None = None):
 29 |         super().__init__(message, code=-32602)  # Invalid params error code
 30 |         self.validation_errors = validation_errors or []
 31 | 
 32 | 
 33 | class ExternalServiceError(ToolError):
 34 |     """Exception for external service errors."""
 35 | 
 36 |     def __init__(self, message: str, service_name: str, status_code: int | None = None):
 37 |         super().__init__(message, code=-32603)  # Internal error code
 38 |         self.service_name = service_name
 39 |         self.status_code = status_code
 40 | 
 41 | 
 42 | class BaseTool(ABC):
 43 |     """Abstract base class for all MCP server tools."""
 44 | 
 45 |     def __init__(self, name: str, description: str):
 46 |         self.name = name
 47 |         self.description = description
 48 |         self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
 49 | 
 50 |     @abstractmethod
 51 |     async def execute(self, **kwargs: Any) -> Any:
 52 |         """Execute the tool with the given arguments."""
 53 |         pass
 54 | 
 55 |     def validate_input(
 56 |         self, input_data: dict[str, Any], model_class: type[BaseModel]
 57 |     ) -> BaseModel:
 58 |         """Validate input data against a Pydantic model."""
 59 |         try:
 60 |             return model_class(**input_data)
 61 |         except ValidationError as e:
 62 |             error_messages = []
 63 |             for error in e.errors():
 64 |                 field = " -> ".join(str(x) for x in error["loc"])
 65 |                 message = error["msg"]
 66 |                 error_messages.append(f"{field}: {message}")
 67 | 
 68 |             raise ValidationToolError(
 69 |                 f"Invalid input for {self.name}: {'; '.join(error_messages)}",
 70 |                 validation_errors=e.errors(),
 71 |             )
 72 | 
 73 |     def create_success_response(self, data: Any) -> dict[str, Any]:
 74 |         """Create a successful tool response."""
 75 |         return {
 76 |             "content": [
 77 |                 {
 78 |                     "type": "text",
 79 |                     "text": str(data) if not isinstance(data, dict | list) else data,
 80 |                 }
 81 |             ],
 82 |             "isError": False,
 83 |         }
 84 | 
 85 |     def create_error_response(self, error: Exception) -> dict[str, Any]:
 86 |         """Create an error tool response."""
 87 |         if isinstance(error, ToolError):
 88 |             error_message = error.message
 89 |         else:
 90 |             error_message = f"An unexpected error occurred: {str(error)}"
 91 | 
 92 |         # Log the full error for debugging
 93 |         self.logger.error(f"Tool {self.name} error: {error}", exc_info=True)
 94 | 
 95 |         return {
 96 |             "content": [
 97 |                 {
 98 |                     "type": "text",
 99 |                     "text": error_message,
100 |                 }
101 |             ],
102 |             "isError": True,
103 |         }
104 | 
105 |     async def safe_execute(self, **kwargs) -> dict[str, Any]:
106 |         """Execute the tool with error handling."""
107 |         try:
108 |             result = await self.execute(**kwargs)
109 |             return self.create_success_response(result)
110 |         except Exception as e:
111 |             return self.create_error_response(e)
112 | 
113 | 
114 | class AsyncHttpMixin:
115 |     """Mixin for tools that need HTTP client capabilities."""
116 | 
117 |     def __init__(self, *args, **kwargs):
118 |         super().__init__(*args, **kwargs)
119 |         self._http_client = None
120 | 
121 |     @property
122 |     def http_client(self):
123 |         """Get or create HTTP client."""
124 |         if self._http_client is None:
125 |             import httpx
126 | 
127 |             self._http_client = httpx.AsyncClient(
128 |                 timeout=30.0,
129 |                 headers={"User-Agent": "MCP-Server/1.0"},
130 |             )
131 |         return self._http_client
132 | 
133 |     async def cleanup(self):
134 |         """Cleanup HTTP client resources."""
135 |         if self._http_client:
136 |             await self._http_client.aclose()
137 |             self._http_client = None
138 | 
139 |     async def make_request(
140 |         self, method: str, url: str, timeout: float = 10.0, **kwargs
141 |     ) -> dict[str, Any]:
142 |         """Make an HTTP request with error handling."""
143 |         try:
144 |             response = await self.http_client.request(
145 |                 method=method, url=url, timeout=timeout, **kwargs
146 |             )
147 |             response.raise_for_status()
148 |             return response.json()
149 |         except httpx.TimeoutException:
150 |             raise ExternalServiceError(
151 |                 f"Request to {url} timed out after {timeout} seconds",
152 |                 service_name="HTTP",
153 |             )
154 |         except httpx.HTTPStatusError as e:
155 |             raise ExternalServiceError(
156 |                 f"HTTP error {e.response.status_code}: {e.response.text}",
157 |                 service_name="HTTP",
158 |                 status_code=e.response.status_code,
159 |             )
160 |         except Exception as e:
161 |             raise ExternalServiceError(
162 |                 f"Failed to make request to {url}: {str(e)}",
163 |                 service_name="HTTP",
164 |             )


--------------------------------------------------------------------------------
/src/mcp_server/tools/date_time.py:
--------------------------------------------------------------------------------
  1 | """Date and time tool for MCP server with timezone support."""
  2 | 
  3 | import zoneinfo
  4 | from datetime import UTC, datetime
  5 | from typing import Any
  6 | 
  7 | from ..models import DateTimeRequest, DateTimeResponse
  8 | from .base import BaseTool, ToolError
  9 | 
 10 | 
 11 | class DateTimeTool(BaseTool):
 12 |     """Tool for getting current date and time in various timezones."""
 13 | 
 14 |     def __init__(self):
 15 |         super().__init__(
 16 |             name="get_date",
 17 |             description="Get current date and time in ISO 8601 format for any timezone",
 18 |         )
 19 | 
 20 |         # Common timezone aliases for user convenience
 21 |         self.timezone_aliases = {
 22 |             "utc": "UTC",
 23 |             "gmt": "UTC",
 24 |             "est": "America/New_York",
 25 |             "pst": "America/Los_Angeles",
 26 |             "cst": "America/Chicago",
 27 |             "mst": "America/Denver",
 28 |             "edt": "America/New_York",
 29 |             "pdt": "America/Los_Angeles",
 30 |             "cdt": "America/Chicago",
 31 |             "mdt": "America/Denver",
 32 |             "bst": "Europe/London",
 33 |             "cet": "Europe/Paris",
 34 |             "jst": "Asia/Tokyo",
 35 |             "aest": "Australia/Sydney",
 36 |         }
 37 | 
 38 |     def parse_timezone(self, timezone_str: str) -> zoneinfo.ZoneInfo | type[UTC]:
 39 |         """Parse timezone string to ZoneInfo object."""
 40 |         # Normalize timezone string
 41 |         tz_lower = timezone_str.lower().strip()
 42 | 
 43 |         # Handle UTC as a special case
 44 |         if tz_lower in ("utc", "gmt"):
 45 |             return UTC
 46 | 
 47 |         # Check aliases
 48 |         if tz_lower in self.timezone_aliases:
 49 |             timezone_str = self.timezone_aliases[tz_lower]
 50 | 
 51 |         # Try to create ZoneInfo object
 52 |         try:
 53 |             if timezone_str.upper() == "UTC":
 54 |                 return UTC
 55 |             else:
 56 |                 return zoneinfo.ZoneInfo(timezone_str)
 57 |         except zoneinfo.ZoneInfoNotFoundError:
 58 |             # Provide helpful error message with suggestions
 59 |             common_timezones = [
 60 |                 "UTC",
 61 |                 "America/New_York",
 62 |                 "America/Los_Angeles",
 63 |                 "America/Chicago",
 64 |                 "Europe/London",
 65 |                 "Europe/Paris",
 66 |                 "Asia/Tokyo",
 67 |                 "Australia/Sydney",
 68 |             ]
 69 |             suggestions = ", ".join(common_timezones)
 70 |             aliases = ", ".join(self.timezone_aliases.keys())
 71 | 
 72 |             raise ToolError(
 73 |                 f"Invalid timezone: '{timezone_str}'. "
 74 |                 f"Common timezones: {suggestions}. "
 75 |                 f"Aliases: {aliases}. "
 76 |                 f"Use IANA timezone names (e.g., 'America/New_York') or aliases."
 77 |             )
 78 | 
 79 |     async def execute(self, **kwargs: Any) -> DateTimeResponse:
 80 |         """Get current date and time for the specified timezone."""
 81 |         timezone = kwargs.get("timezone", "UTC")
 82 | 
 83 |         # Validate input
 84 |         request = self.validate_input({"timezone": timezone}, DateTimeRequest)
 85 | 
 86 |         # Parse timezone
 87 |         tz = self.parse_timezone(request.timezone)
 88 | 
 89 |         self.logger.info(f"Getting current time for timezone: {timezone}")
 90 | 
 91 |         # Get current time in the specified timezone
 92 |         if isinstance(tz, zoneinfo.ZoneInfo):
 93 |             current_time = datetime.now(tz)
 94 |             tz_name = str(tz)
 95 |         else:  # UTC
 96 |             current_time = datetime.now(tz)
 97 |             tz_name = "UTC"
 98 | 
 99 |         # Format as ISO 8601
100 |         iso_datetime = current_time.isoformat()
101 | 
102 |         # Get Unix timestamp
103 |         timestamp = current_time.timestamp()
104 | 
105 |         self.logger.info(f"Current time in {tz_name}: {iso_datetime}")
106 | 
107 |         return DateTimeResponse(
108 |             datetime=iso_datetime,
109 |             timezone=tz_name,
110 |             timestamp=timestamp,
111 |         )
112 | 
113 |     def format_result(self, response: DateTimeResponse) -> str:
114 |         """Format date/time data for display."""
115 |         # Parse the ISO datetime to extract components
116 |         try:
117 |             dt = datetime.fromisoformat(response.datetime)
118 |             date_part = dt.strftime("%Y-%m-%d")
119 |             time_part = dt.strftime("%H:%M:%S")
120 |             weekday = dt.strftime("%A")
121 | 
122 |             result = "🕐 **Current Date & Time**\n"
123 |             result += f"📅 Date: **{date_part}** ({weekday})\n"
124 |             result += f"⏰ Time: **{time_part}**\n"
125 |             result += f"🌍 Timezone: **{response.timezone}**\n"
126 |             result += f"📋 ISO 8601: `{response.datetime}`\n"
127 |             result += f"🔢 Unix Timestamp: `{int(response.timestamp)}`"
128 | 
129 |             return result
130 | 
131 |         except ValueError:
132 |             # Fallback if datetime parsing fails
133 |             return (
134 |                 f"🕐 **Current Date & Time**\n"
135 |                 f"📋 ISO 8601: `{response.datetime}`\n"
136 |                 f"🌍 Timezone: **{response.timezone}**\n"
137 |                 f"🔢 Unix Timestamp: `{int(response.timestamp)}`"
138 |             )
139 | 
140 |     async def safe_execute(self, **kwargs) -> dict[str, Any]:
141 |         """Execute date/time lookup with formatted output."""
142 |         try:
143 |             result = await self.execute(**kwargs)
144 |             formatted_result = self.format_result(result)
145 | 
146 |             return {
147 |                 "content": [
148 |                     {
149 |                         "type": "text",
150 |                         "text": formatted_result,
151 |                     }
152 |                 ],
153 |                 "isError": False,
154 |             }
155 |         except Exception as e:
156 |             return self.create_error_response(e)
157 | 
158 |     def get_available_timezones(self) -> list[str]:
159 |         """Get a list of common available timezones."""
160 |         common_zones = [
161 |             "UTC",
162 |             "America/New_York",
163 |             "America/Los_Angeles",
164 |             "America/Chicago",
165 |             "America/Denver",
166 |             "America/Phoenix",
167 |             "America/Anchorage",
168 |             "America/Honolulu",
169 |             "America/Toronto",
170 |             "America/Vancouver",
171 |             "Europe/London",
172 |             "Europe/Paris",
173 |             "Europe/Berlin",
174 |             "Europe/Rome",
175 |             "Europe/Madrid",
176 |             "Europe/Amsterdam",
177 |             "Europe/Stockholm",
178 |             "Europe/Moscow",
179 |             "Asia/Tokyo",
180 |             "Asia/Shanghai",
181 |             "Asia/Kolkata",
182 |             "Asia/Dubai",
183 |             "Asia/Singapore",
184 |             "Australia/Sydney",
185 |             "Australia/Melbourne",
186 |             "Pacific/Auckland",
187 |         ]
188 |         return sorted(common_zones + list(self.timezone_aliases.values()))


--------------------------------------------------------------------------------
/src/mcp_server/tools/dice.py:
--------------------------------------------------------------------------------
 1 | """Dice rolling tool for MCP server."""
 2 | 
 3 | import random
 4 | import re
 5 | from typing import Any
 6 | 
 7 | from ..models import DiceRollRequest, DiceRollResponse
 8 | from .base import BaseTool, ToolError
 9 | 
10 | 
11 | class DiceRollTool(BaseTool):
12 |     """Tool for rolling dice using standard notation."""
13 | 
14 |     def __init__(self):
15 |         super().__init__(
16 |             name="roll_dice",
17 |             description="Roll dice using standard notation like '2d6' or '1d20'",
18 |         )
19 |         self.notation_pattern = re.compile(r"^(\d+)d(\d+)

quot;)
20 | 
21 |     async def execute(self, **kwargs: Any) -> DiceRollResponse:
22 |         """Execute dice roll with the given notation."""
23 |         notation = kwargs.get("notation")
24 |         if not notation:
25 |             raise ToolError("Missing required parameter: notation")
26 | 
27 |         # Validate input using Pydantic model
28 |         request = self.validate_input({"notation": notation}, DiceRollRequest)
29 | 
30 |         # Parse the notation
31 |         match = self.notation_pattern.match(request.notation)
32 |         if not match:
33 |             raise ToolError(f"Invalid dice notation: {notation}")
34 | 
35 |         dice_count = int(match.group(1))
36 |         sides = int(match.group(2))
37 | 
38 |         self.logger.info(f"Rolling {dice_count}d{sides}")
39 | 
40 |         # Generate random values for each die
41 |         values = []
42 |         for _ in range(dice_count):
43 |             roll = random.randint(1, sides)
44 |             values.append(roll)
45 | 
46 |         total = sum(values)
47 | 
48 |         self.logger.info(f"Dice roll result: {values} (total: {total})")
49 | 
50 |         # Return structured response
51 |         return DiceRollResponse(
52 |             values=values,
53 |             total=total,
54 |             notation=str(notation),  # Return original notation as provided
55 |         )
56 | 
57 |     def format_result(self, response: DiceRollResponse) -> str:
58 |         """Format dice roll result for display."""
59 |         if len(response.values) == 1:
60 |             return f"🎲 Rolled {response.notation}: **{response.values[0]}**"
61 |         else:
62 |             values_str = ", ".join(map(str, response.values))
63 |             return (
64 |                 f"🎲 Rolled {response.notation}: [{values_str}] = **{response.total}**"
65 |             )
66 | 
67 |     async def safe_execute(self, **kwargs) -> dict[str, Any]:
68 |         """Execute dice roll with formatted output."""
69 |         try:
70 |             result = await self.execute(**kwargs)
71 |             formatted_result = self.format_result(result)
72 | 
73 |             return {
74 |                 "content": [
75 |                     {
76 |                         "type": "text",
77 |                         "text": formatted_result,
78 |                     }
79 |                 ],
80 |                 "isError": False,
81 |             }
82 |         except Exception as e:
83 |             return self.create_error_response(e)


--------------------------------------------------------------------------------
/src/mcp_server/tools/weather.py:
--------------------------------------------------------------------------------
  1 | """Weather tool for MCP server using Open-Meteo API."""
  2 | 
  3 | from datetime import datetime
  4 | from typing import Any
  5 | 
  6 | from ..models import WeatherRequest, WeatherResponse
  7 | from .base import AsyncHttpMixin, BaseTool, ExternalServiceError, ToolError
  8 | 
  9 | 
 10 | class WeatherTool(BaseTool, AsyncHttpMixin):
 11 |     """Tool for getting current weather data."""
 12 | 
 13 |     def __init__(self):
 14 |         super().__init__(
 15 |             name="get_weather",
 16 |             description="Get current weather conditions for a location",
 17 |         )
 18 |         self.api_base = "https://api.open-meteo.com/v1"
 19 | 
 20 |         # Basic city to coordinates mapping
 21 |         # In production, this would use a proper geocoding service
 22 |         self.city_coords = {
 23 |             "san francisco": (37.7749, -122.4194),
 24 |             "new york": (40.7128, -74.0060),
 25 |             "london": (51.5074, -0.1278),
 26 |             "paris": (48.8566, 2.3522),
 27 |             "tokyo": (35.6762, 139.6503),
 28 |             "sydney": (-33.8688, 151.2093),
 29 |             "los angeles": (34.0522, -118.2437),
 30 |             "chicago": (41.8781, -87.6298),
 31 |             "miami": (25.7617, -80.1918),
 32 |             "seattle": (47.6062, -122.3321),
 33 |             "vancouver": (49.2827, -123.1207),
 34 |             "toronto": (43.6532, -79.3832),
 35 |             "berlin": (52.5200, 13.4050),
 36 |             "rome": (41.9028, 12.4964),
 37 |             "madrid": (40.4168, -3.7038),
 38 |             "moscow": (55.7558, 37.6176),
 39 |             "beijing": (39.9042, 116.4074),
 40 |             "mumbai": (19.0760, 72.8777),
 41 |             "cairo": (30.0444, 31.2357),
 42 |             "lagos": (6.5244, 3.3792),
 43 |         }
 44 | 
 45 |         # Weather code to description mapping (subset of WMO codes)
 46 |         self.weather_codes = {
 47 |             0: "Clear sky",
 48 |             1: "Mainly clear",
 49 |             2: "Partly cloudy",
 50 |             3: "Overcast",
 51 |             45: "Fog",
 52 |             48: "Depositing rime fog",
 53 |             51: "Light drizzle",
 54 |             53: "Moderate drizzle",
 55 |             55: "Dense drizzle",
 56 |             61: "Slight rain",
 57 |             63: "Moderate rain",
 58 |             65: "Heavy rain",
 59 |             71: "Slight snow",
 60 |             73: "Moderate snow",
 61 |             75: "Heavy snow",
 62 |             77: "Snow grains",
 63 |             80: "Slight rain showers",
 64 |             81: "Moderate rain showers",
 65 |             82: "Violent rain showers",
 66 |             85: "Slight snow showers",
 67 |             86: "Heavy snow showers",
 68 |             95: "Thunderstorm",
 69 |             96: "Thunderstorm with slight hail",
 70 |             99: "Thunderstorm with heavy hail",
 71 |         }
 72 | 
 73 |     def parse_location(self, location: str) -> tuple[float, float]:
 74 |         """Parse location string to get coordinates."""
 75 |         location_lower = location.lower().strip()
 76 | 
 77 |         # Check if it's in our city mapping
 78 |         if location_lower in self.city_coords:
 79 |             return self.city_coords[location_lower]
 80 | 
 81 |         # Try to parse as "lat,lon" coordinates
 82 |         try:
 83 |             parts = location.split(",")
 84 |             if len(parts) == 2:
 85 |                 lat = float(parts[0].strip())
 86 |                 lon = float(parts[1].strip())
 87 | 
 88 |                 # Basic validation for reasonable coordinate ranges
 89 |                 if -90 <= lat <= 90 and -180 <= lon <= 180:
 90 |                     return lat, lon
 91 |         except ValueError:
 92 |             pass
 93 | 
 94 |         # If we can't parse the location, raise an error
 95 |         available_cities = ", ".join(sorted(self.city_coords.keys()))
 96 |         raise ToolError(
 97 |             f"Unknown location: '{location}'. "
 98 |             f"Please use coordinates (lat,lon) or one of: {available_cities}"
 99 |         )
100 | 
101 |     def weather_code_to_text(self, code: int) -> str:
102 |         """Convert weather code to readable description."""
103 |         return self.weather_codes.get(code, f"Unknown weather condition (code: {code})")
104 | 
105 |     async def execute(self, **kwargs: Any) -> WeatherResponse:
106 |         """Get weather data for the specified location."""
107 |         location = kwargs.get("location")
108 |         if not location:
109 |             raise ToolError("Missing required parameter: location")
110 | 
111 |         # Validate input
112 |         request = self.validate_input({"location": location}, WeatherRequest)
113 | 
114 |         # Parse location to coordinates
115 |         lat, lon = self.parse_location(request.location)
116 | 
117 |         self.logger.info(f"Getting weather for {location} ({lat}, {lon})")
118 | 
119 |         # Make API request to Open-Meteo
120 |         try:
121 |             data = await self.make_request(
122 |                 method="GET",
123 |                 url=f"{self.api_base}/forecast",
124 |                 params={
125 |                     "latitude": lat,
126 |                     "longitude": lon,
127 |                     "current": (
128 |                         "temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m"
129 |                     ),
130 |                     "timezone": "auto",
131 |                 },
132 |                 timeout=15.0,
133 |             )
134 | 
135 |             # Extract current weather data
136 |             current = data.get("current", {})
137 |             if not current:
138 |                 raise ExternalServiceError(
139 |                     "No current weather data available",
140 |                     service_name="Open-Meteo",
141 |                 )
142 | 
143 |             temperature = current.get("temperature_2m")
144 |             humidity = current.get("relative_humidity_2m")
145 |             weather_code = current.get("weather_code")
146 |             wind_speed = current.get("wind_speed_10m")
147 |             timestamp = current.get("time")
148 | 
149 |             if temperature is None or weather_code is None or wind_speed is None:
150 |                 raise ExternalServiceError(
151 |                     "Incomplete weather data received",
152 |                     service_name="Open-Meteo",
153 |                 )
154 | 
155 |             condition = self.weather_code_to_text(weather_code)
156 | 
157 |             self.logger.info(
158 |                 f"Weather data retrieved: {temperature}°C, {condition}, "
159 |                 f"{wind_speed} km/h wind"
160 |             )
161 | 
162 |             return WeatherResponse(
163 |                 location=str(location),
164 |                 temperature=temperature,
165 |                 condition=condition,
166 |                 wind_speed=wind_speed,
167 |                 humidity=humidity,
168 |                 timestamp=timestamp,
169 |             )
170 | 
171 |         except ExternalServiceError:
172 |             raise
173 |         except Exception as e:
174 |             raise ExternalServiceError(
175 |                 f"Failed to retrieve weather data: {str(e)}",
176 |                 service_name="Open-Meteo",
177 |             )
178 | 
179 |     def format_result(self, response: WeatherResponse) -> str:
180 |         """Format weather data for display."""
181 |         result = f"🌤️ **Weather for {response.location}**\n"
182 |         result += f"🌡️ Temperature: **{response.temperature}°C**\n"
183 |         result += f"☁️ Condition: **{response.condition}**\n"
184 |         result += f"💨 Wind Speed: **{response.wind_speed} km/h**"
185 | 
186 |         if response.humidity is not None:
187 |             result += f"\n💧 Humidity: **{response.humidity}%**"
188 | 
189 |         if response.timestamp:
190 |             try:
191 |                 # Parse and format timestamp
192 |                 dt = datetime.fromisoformat(response.timestamp.replace("Z", "+00:00"))
193 |                 result += f"\n🕐 Updated: {dt.strftime('%Y-%m-%d %H:%M UTC')}"
194 |             except ValueError:
195 |                 pass
196 | 
197 |         return result
198 | 
199 |     async def safe_execute(self, **kwargs) -> dict[str, Any]:
200 |         """Execute weather lookup with formatted output."""
201 |         try:
202 |             result = await self.execute(**kwargs)
203 |             formatted_result = self.format_result(result)
204 | 
205 |             return {
206 |                 "content": [
207 |                     {
208 |                         "type": "text",
209 |                         "text": formatted_result,
210 |                     }
211 |                 ],
212 |                 "isError": False,
213 |             }
214 |         except Exception as e:
215 |             return self.create_error_response(e)


--------------------------------------------------------------------------------
/src/py.typed:
--------------------------------------------------------------------------------
1 | # PEP 561 – Distributing and Packaging Type Information
2 | # https://peps.python.org/pep-0561/


--------------------------------------------------------------------------------
/tests/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/tests/__init__.py


--------------------------------------------------------------------------------
/tests/fixtures/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/tests/fixtures/__init__.py


--------------------------------------------------------------------------------
/tests/fixtures/mcp_messages.py:
--------------------------------------------------------------------------------
 1 | """Test fixtures for MCP messages and responses."""
 2 | 
 3 | from typing import Any, Dict
 4 | 
 5 | 
 6 | class MCPMessageFixtures:
 7 |     """Collection of MCP message fixtures for testing."""
 8 | 
 9 |     @staticmethod
10 |     def tool_call_request(tool_name: str, arguments: Dict[str, Any], request_id: int = 1) -> Dict[str, Any]:
11 |         """Create a standard MCP tool call request."""
12 |         return {
13 |             "jsonrpc": "2.0",
14 |             "method": "tools/call",
15 |             "params": {
16 |                 "name": tool_name,
17 |                 "arguments": arguments,
18 |             },
19 |             "id": request_id,
20 |         }
21 | 
22 |     @staticmethod
23 |     def success_response(content: Any, request_id: int = 1) -> Dict[str, Any]:
24 |         """Create a successful MCP response."""
25 |         return {
26 |             "jsonrpc": "2.0",
27 |             "id": request_id,
28 |             "result": {
29 |                 "content": [
30 |                     {
31 |                         "type": "text",
32 |                         "text": content,
33 |                     }
34 |                 ],
35 |                 "isError": False,
36 |             },
37 |         }
38 | 
39 |     @staticmethod
40 |     def error_response(error_message: str, request_id: int = 1) -> Dict[str, Any]:
41 |         """Create an error MCP response."""
42 |         return {
43 |             "jsonrpc": "2.0",
44 |             "id": request_id,
45 |             "result": {
46 |                 "content": [
47 |                     {
48 |                         "type": "text",
49 |                         "text": error_message,
50 |                     }
51 |                 ],
52 |                 "isError": True,
53 |             },
54 |         }
55 | 
56 | 
57 | class WeatherAPIFixtures:
58 |     """Collection of weather API response fixtures."""
59 | 
60 |     @staticmethod
61 |     def current_weather_response(
62 |         temperature: float = 20.0,
63 |         weather_code: int = 0,
64 |         wind_speed: float = 10.0,
65 |         humidity: float = 65.0,
66 |     ) -> Dict[str, Any]:
67 |         """Create a mock Open-Meteo API response."""
68 |         return {
69 |             "current": {
70 |                 "time": "2025-07-07T14:30:00Z",
71 |                 "temperature_2m": temperature,
72 |                 "relative_humidity_2m": humidity,
73 |                 "weather_code": weather_code,
74 |                 "wind_speed_10m": wind_speed,
75 |             },
76 |             "current_units": {
77 |                 "time": "iso8601",
78 |                 "temperature_2m": "°C",
79 |                 "relative_humidity_2m": "%",
80 |                 "weather_code": "wmo code",
81 |                 "wind_speed_10m": "km/h",
82 |             },
83 |         }
84 | 
85 |     @staticmethod
86 |     def api_error_response(status_code: int = 500) -> Dict[str, Any]:
87 |         """Create a mock API error response."""
88 |         return {
89 |             "error": True,
90 |             "reason": "Internal server error" if status_code == 500 else "Bad request",
91 |         }


--------------------------------------------------------------------------------
/tests/test_gui.py:
--------------------------------------------------------------------------------
  1 | """Tests for GUI components and functionality."""
  2 | 
  3 | import pytest
  4 | from datetime import datetime
  5 | from unittest.mock import Mock, patch
  6 | 
  7 | from src.gui.models.gui_models import GUIInteraction, GUISession, ConnectionStatus
  8 | from src.gui.utils.formatting import format_json_for_display, format_error_message, format_execution_time
  9 | from src.gui.utils.validation import validate_dice_notation, validate_location, validate_timezone
 10 | 
 11 | 
 12 | class TestGUIModels:
 13 |     """Test GUI data models."""
 14 |     
 15 |     def test_gui_session_model(self):
 16 |         """Test GUI session model validation."""
 17 |         session = GUISession()
 18 |         assert not session.connected
 19 |         assert session.server_path == "src/mcp_server/server.py"
 20 |         assert len(session.interaction_history) == 0
 21 |         assert session.current_tool is None
 22 | 
 23 |     def test_gui_interaction_model(self):
 24 |         """Test GUI interaction model."""
 25 |         interaction = GUIInteraction(
 26 |             tool_name="roll_dice",
 27 |             arguments={"notation": "2d6"},
 28 |             request_payload={"tool": "roll_dice", "arguments": {"notation": "2d6"}},
 29 |             response_payload={"success": True, "result": {"values": [3, 5], "total": 8}},
 30 |             success=True
 31 |         )
 32 |         assert interaction.tool_name == "roll_dice"
 33 |         assert interaction.success is True
 34 |         assert interaction.timestamp is not None
 35 |         assert isinstance(interaction.timestamp, datetime)
 36 | 
 37 |     def test_connection_status_model(self):
 38 |         """Test connection status model."""
 39 |         status = ConnectionStatus(
 40 |             server_path="src/mcp_server/server.py",
 41 |             connected=True,
 42 |             available_tools=["roll_dice", "get_weather"]
 43 |         )
 44 |         assert status.connected is True
 45 |         assert len(status.available_tools) == 2
 46 |         assert "roll_dice" in status.available_tools
 47 | 
 48 | 
 49 | class TestValidationUtils:
 50 |     """Test validation utilities."""
 51 |     
 52 |     def test_dice_notation_validation(self):
 53 |         """Test dice notation validation."""
 54 |         # Valid notations
 55 |         assert validate_dice_notation("2d6") is True
 56 |         assert validate_dice_notation("1d20") is True
 57 |         assert validate_dice_notation("10d10") is True
 58 |         
 59 |         # Invalid notations
 60 |         assert validate_dice_notation("invalid") is False
 61 |         assert validate_dice_notation("2d") is False
 62 |         assert validate_dice_notation("d6") is False
 63 |         assert validate_dice_notation("") is False
 64 |         assert validate_dice_notation(None) is False
 65 |         
 66 |         # Edge cases
 67 |         assert validate_dice_notation("0d6") is False  # No dice
 68 |         assert validate_dice_notation("2d1") is False  # Invalid sides
 69 |         assert validate_dice_notation("101d6") is False  # Too many dice
 70 | 
 71 |     def test_location_validation(self):
 72 |         """Test location validation."""
 73 |         # Valid locations
 74 |         assert validate_location("San Francisco") is True
 75 |         assert validate_location("New York") is True
 76 |         assert validate_location("37.7749,-122.4194") is True
 77 |         assert validate_location("40.7128,-74.0060") is True
 78 |         
 79 |         # Invalid locations
 80 |         assert validate_location("") is False
 81 |         assert validate_location("A") is False  # Too short
 82 |         assert validate_location("123") is False  # Numbers only
 83 |         assert validate_location(None) is False
 84 | 
 85 |     def test_timezone_validation(self):
 86 |         """Test timezone validation."""
 87 |         # Valid timezones
 88 |         assert validate_timezone("UTC") is True
 89 |         assert validate_timezone("America/New_York") is True
 90 |         assert validate_timezone("Europe/London") is True
 91 |         assert validate_timezone("Asia/Tokyo") is True
 92 |         
 93 |         # Invalid timezones
 94 |         assert validate_timezone("") is False
 95 |         assert validate_timezone("Invalid/Zone") is True  # Would pass pattern check
 96 |         assert validate_timezone("123") is False
 97 |         assert validate_timezone(None) is False
 98 | 
 99 | 
100 | class TestFormattingUtils:
101 |     """Test formatting utilities."""
102 |     
103 |     def test_json_formatting(self):
104 |         """Test JSON formatting for display."""
105 |         data = {"tool": "roll_dice", "result": {"values": [3, 5], "total": 8}}
106 |         formatted = format_json_for_display(data)
107 |         assert isinstance(formatted, str)
108 |         assert "roll_dice" in formatted
109 |         assert "values" in formatted
110 |         
111 |         # Test with invalid data
112 |         formatted_error = format_json_for_display(set())  # Sets aren't JSON serializable
113 |         assert "Error formatting JSON" in formatted_error
114 | 
115 |     def test_error_message_formatting(self):
116 |         """Test error message formatting."""
117 |         # Test removal of prefixes
118 |         assert format_error_message("Exception: Something went wrong") == "Something went wrong"
119 |         assert format_error_message("Error: Invalid input") == "Invalid input"
120 |         
121 |         # Test capitalization
122 |         assert format_error_message("invalid dice notation") == "Invalid dice notation"
123 |         
124 |         # Test empty string
125 |         assert format_error_message("") == ""
126 | 
127 |     def test_execution_time_formatting(self):
128 |         """Test execution time formatting."""
129 |         # Test milliseconds
130 |         assert format_execution_time(0.5) == "500ms"
131 |         assert format_execution_time(0.123) == "123ms"
132 |         
133 |         # Test seconds
134 |         assert format_execution_time(1.5) == "1.50s"
135 |         assert format_execution_time(30.25) == "30.25s"
136 |         
137 |         # Test minutes
138 |         assert format_execution_time(65.5) == "1m 5.5s"
139 |         assert format_execution_time(125.75) == "2m 5.8s"
140 | 
141 | 
142 | class TestConnectionManager:
143 |     """Test connection manager component."""
144 |     
145 |     @patch('src.gui.components.connection.MCPClient')
146 |     def test_connection_success(self, mock_client_class):
147 |         """Test successful connection."""
148 |         # Mock client instance
149 |         mock_client = Mock()
150 |         mock_client.available_tools = ["roll_dice", "get_weather", "get_date"]
151 |         mock_client_class.return_value = mock_client
152 |         
153 |         # This would require mocking Streamlit session state
154 |         # which is complex, so we're testing the basic structure
155 |         assert mock_client_class is not None
156 | 
157 |     def test_connection_failure(self):
158 |         """Test connection failure handling."""
159 |         # This would test error handling in connection
160 |         # Placeholder for more complex Streamlit testing
161 |         pass
162 | 
163 | 
164 | class TestToolForms:
165 |     """Test tool form components."""
166 |     
167 |     def test_dice_form_validation(self):
168 |         """Test dice form validation logic."""
169 |         from src.gui.components.tool_forms import ToolForms
170 |         
171 |         tool_forms = ToolForms()
172 |         assert tool_forms._validate_dice_notation("2d6") is True
173 |         assert tool_forms._validate_dice_notation("invalid") is False
174 | 
175 |     def test_tool_execution_flow(self):
176 |         """Test tool execution flow."""
177 |         # This would test the complete flow from form submission
178 |         # to result display - requires Streamlit mocking
179 |         pass
180 | 
181 | 
182 | @pytest.mark.asyncio
183 | async def test_async_operations():
184 |     """Test async operations in GUI components."""
185 |     # Placeholder for testing async MCP client operations
186 |     # This would test the asyncio.run() calls in the GUI
187 |     pass
188 | 
189 | 
190 | def test_session_state_management():
191 |     """Test session state management patterns."""
192 |     # Test session initialization
193 |     session = GUISession()
194 |     assert session.connected is False
195 |     assert len(session.interaction_history) == 0
196 |     
197 |     # Test adding interactions
198 |     interaction = GUIInteraction(
199 |         tool_name="test_tool",
200 |         arguments={"test": "value"},
201 |         request_payload={"tool": "test_tool"},
202 |         response_payload={"success": True},
203 |         success=True
204 |     )
205 |     
206 |     session.interaction_history.append(interaction)
207 |     assert len(session.interaction_history) == 1
208 |     assert session.interaction_history[0].tool_name == "test_tool"
209 | 
210 | 
211 | def test_history_management():
212 |     """Test history management functionality."""
213 |     # Create test interactions
214 |     interactions = []
215 |     for i in range(3):
216 |         interaction = GUIInteraction(
217 |             tool_name=f"tool_{i}",
218 |             arguments={"index": i},
219 |             request_payload={"tool": f"tool_{i}"},
220 |             response_payload={"success": True, "index": i},
221 |             success=True
222 |         )
223 |         interactions.append(interaction)
224 |     
225 |     # Test history ordering (latest first)
226 |     assert interactions[-1].arguments["index"] == 2
227 |     assert interactions[0].arguments["index"] == 0


--------------------------------------------------------------------------------
/tests/test_mcp_server.py:
--------------------------------------------------------------------------------
  1 | """Tests for the MCP server integration."""
  2 | 
  3 | import pytest
  4 | from unittest.mock import AsyncMock, patch
  5 | 
  6 | from src.mcp_server.server import dice_tool, weather_tool, datetime_tool, cleanup_server
  7 | from tests.fixtures.mcp_messages import MCPMessageFixtures, WeatherAPIFixtures
  8 | 
  9 | 
 10 | class TestMCPServerIntegration:
 11 |     """Test suite for MCP server integration."""
 12 | 
 13 |     @pytest.mark.asyncio
 14 |     async def test_dice_tool_integration(self):
 15 |         """Test dice tool integration through MCP server."""
 16 |         # Import the MCP tool function
 17 |         from src.mcp_server.server import roll_dice
 18 | 
 19 |         result = await roll_dice(notation="2d6")
 20 | 
 21 |         assert "content" in result
 22 |         assert "isError" in result
 23 |         assert result["isError"] is False
 24 |         assert "🎲" in result["content"][0]["text"]
 25 |         assert "2d6" in result["content"][0]["text"]
 26 | 
 27 |     @pytest.mark.asyncio
 28 |     async def test_weather_tool_integration(self):
 29 |         """Test weather tool integration through MCP server."""
 30 |         from src.mcp_server.server import get_weather
 31 | 
 32 |         mock_response = WeatherAPIFixtures.current_weather_response()
 33 | 
 34 |         with patch.object(weather_tool, 'make_request', return_value=mock_response):
 35 |             result = await get_weather(location="San Francisco")
 36 | 
 37 |             assert "content" in result
 38 |             assert "isError" in result
 39 |             assert result["isError"] is False
 40 |             assert "🌤️" in result["content"][0]["text"]
 41 |             assert "San Francisco" in result["content"][0]["text"]
 42 | 
 43 |     @pytest.mark.asyncio
 44 |     async def test_datetime_tool_integration(self):
 45 |         """Test date/time tool integration through MCP server."""
 46 |         from src.mcp_server.server import get_date
 47 | 
 48 |         result = await get_date(timezone="UTC")
 49 | 
 50 |         assert "content" in result
 51 |         assert "isError" in result
 52 |         assert result["isError"] is False
 53 |         assert "🕐" in result["content"][0]["text"]
 54 |         assert "UTC" in result["content"][0]["text"]
 55 | 
 56 |     @pytest.mark.asyncio
 57 |     async def test_dice_tool_error_handling(self):
 58 |         """Test error handling in dice tool integration."""
 59 |         from src.mcp_server.server import roll_dice
 60 | 
 61 |         result = await roll_dice(notation="invalid")
 62 | 
 63 |         assert "content" in result
 64 |         assert "isError" in result
 65 |         assert result["isError"] is True
 66 |         assert "Invalid input" in result["content"][0]["text"]
 67 | 
 68 |     @pytest.mark.asyncio
 69 |     async def test_weather_tool_error_handling(self):
 70 |         """Test error handling in weather tool integration."""
 71 |         from src.mcp_server.server import get_weather
 72 | 
 73 |         result = await get_weather(location="Unknown City")
 74 | 
 75 |         assert "content" in result
 76 |         assert "isError" in result
 77 |         assert result["isError"] is True
 78 |         assert "Unknown location" in result["content"][0]["text"]
 79 | 
 80 |     @pytest.mark.asyncio
 81 |     async def test_datetime_tool_error_handling(self):
 82 |         """Test error handling in date/time tool integration."""
 83 |         from src.mcp_server.server import get_date
 84 | 
 85 |         result = await get_date(timezone="Invalid/Timezone")
 86 | 
 87 |         assert "content" in result
 88 |         assert "isError" in result
 89 |         assert result["isError"] is True
 90 |         assert "Invalid timezone" in result["content"][0]["text"]
 91 | 
 92 |     @pytest.mark.asyncio
 93 |     async def test_help_resource(self):
 94 |         """Test help resource is available."""
 95 |         from src.mcp_server.server import get_help
 96 | 
 97 |         help_text = await get_help()
 98 | 
 99 |         assert isinstance(help_text, str)
100 |         assert "roll_dice" in help_text
101 |         assert "get_weather" in help_text
102 |         assert "get_date" in help_text
103 |         assert "🎲" in help_text
104 | 
105 |     @pytest.mark.asyncio
106 |     async def test_cleanup_server(self):
107 |         """Test server cleanup functionality."""
108 |         # Mock the weather tool's cleanup method
109 |         weather_tool.cleanup = AsyncMock()
110 | 
111 |         await cleanup_server()
112 | 
113 |         weather_tool.cleanup.assert_called_once()
114 | 
115 |     @pytest.mark.asyncio
116 |     async def test_cleanup_server_with_error(self):
117 |         """Test server cleanup handles errors gracefully."""
118 |         # Mock the weather tool's cleanup method to raise an error
119 |         weather_tool.cleanup = AsyncMock(side_effect=Exception("Cleanup error"))
120 | 
121 |         # Should not raise an exception
122 |         await cleanup_server()
123 | 
124 |         weather_tool.cleanup.assert_called_once()
125 | 
126 |     def test_tool_instances_exist(self):
127 |         """Test that tool instances are properly created."""
128 |         assert dice_tool is not None
129 |         assert weather_tool is not None
130 |         assert datetime_tool is not None
131 | 
132 |         assert dice_tool.name == "roll_dice"
133 |         assert weather_tool.name == "get_weather"
134 |         assert datetime_tool.name == "get_date"
135 | 
136 |     @pytest.mark.asyncio
137 |     async def test_mcp_tool_docstrings(self):
138 |         """Test that MCP tool functions have proper docstrings."""
139 |         from src.mcp_server.server import roll_dice, get_weather, get_date
140 | 
141 |         assert roll_dice.__doc__ is not None
142 |         assert "dice" in roll_dice.__doc__.lower()
143 |         assert "notation" in roll_dice.__doc__.lower()
144 | 
145 |         assert get_weather.__doc__ is not None
146 |         assert "weather" in get_weather.__doc__.lower()
147 |         assert "location" in get_weather.__doc__.lower()
148 | 
149 |         assert get_date.__doc__ is not None
150 |         assert "date" in get_date.__doc__.lower()
151 |         assert "timezone" in get_date.__doc__.lower()
152 | 
153 |     @pytest.mark.asyncio
154 |     async def test_all_tools_return_proper_format(self):
155 |         """Test that all tools return the expected MCP response format."""
156 |         from src.mcp_server.server import roll_dice, get_date
157 | 
158 |         # Test dice tool
159 |         dice_result = await roll_dice(notation="1d6")
160 |         assert "content" in dice_result
161 |         assert "isError" in dice_result
162 |         assert isinstance(dice_result["content"], list)
163 |         assert len(dice_result["content"]) == 1
164 |         assert "type" in dice_result["content"][0]
165 |         assert "text" in dice_result["content"][0]
166 | 
167 |         # Test date tool
168 |         date_result = await get_date(timezone="UTC")
169 |         assert "content" in date_result
170 |         assert "isError" in date_result
171 |         assert isinstance(date_result["content"], list)
172 |         assert len(date_result["content"]) == 1
173 |         assert "type" in date_result["content"][0]
174 |         assert "text" in date_result["content"][0]
175 | 
176 |     @pytest.mark.asyncio
177 |     async def test_weather_tool_with_coordinates(self):
178 |         """Test weather tool with coordinate input."""
179 |         from src.mcp_server.server import get_weather
180 | 
181 |         mock_response = WeatherAPIFixtures.current_weather_response()
182 | 
183 |         with patch.object(weather_tool, 'make_request', return_value=mock_response):
184 |             result = await get_weather(location="37.7749,-122.4194")
185 | 
186 |             assert "content" in result
187 |             assert "isError" in result
188 |             assert result["isError"] is False
189 |             assert "37.7749,-122.4194" in result["content"][0]["text"]


--------------------------------------------------------------------------------
/tests/test_tools/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/qte77/context-engineering-template/feat-create-examples/tests/test_tools/__init__.py


--------------------------------------------------------------------------------
/tests/test_tools/test_dice.py:
--------------------------------------------------------------------------------
  1 | """Tests for the dice rolling tool."""
  2 | 
  3 | import pytest
  4 | 
  5 | from src.mcp_server.tools.dice import DiceRollTool
  6 | from src.mcp_server.tools.base import ValidationToolError
  7 | 
  8 | 
  9 | class TestDiceRollTool:
 10 |     """Test suite for DiceRollTool."""
 11 | 
 12 |     @pytest.fixture
 13 |     def dice_tool(self):
 14 |         """Create a DiceRollTool instance for testing."""
 15 |         return DiceRollTool()
 16 | 
 17 |     @pytest.mark.asyncio
 18 |     async def test_roll_dice_valid_notation(self, dice_tool):
 19 |         """Test valid dice notation works correctly."""
 20 |         result = await dice_tool.execute(notation="2d6")
 21 | 
 22 |         assert isinstance(result.values, list)
 23 |         assert len(result.values) == 2
 24 |         assert all(1 <= v <= 6 for v in result.values)
 25 |         assert result.total == sum(result.values)
 26 |         assert result.notation == "2d6"
 27 | 
 28 |     @pytest.mark.asyncio
 29 |     async def test_roll_dice_single_die(self, dice_tool):
 30 |         """Test rolling a single die."""
 31 |         result = await dice_tool.execute(notation="1d20")
 32 | 
 33 |         assert len(result.values) == 1
 34 |         assert 1 <= result.values[0] <= 20
 35 |         assert result.total == result.values[0]
 36 |         assert result.notation == "1d20"
 37 | 
 38 |     @pytest.mark.asyncio
 39 |     async def test_roll_dice_multiple_dice(self, dice_tool):
 40 |         """Test rolling multiple dice."""
 41 |         result = await dice_tool.execute(notation="4d10")
 42 | 
 43 |         assert len(result.values) == 4
 44 |         assert all(1 <= v <= 10 for v in result.values)
 45 |         assert result.total == sum(result.values)
 46 |         assert result.notation == "4d10"
 47 | 
 48 |     @pytest.mark.asyncio
 49 |     async def test_roll_dice_invalid_notation_format(self, dice_tool):
 50 |         """Test invalid dice notation raises ValidationError."""
 51 |         with pytest.raises(ValidationToolError) as exc_info:
 52 |             await dice_tool.execute(notation="d6")
 53 | 
 54 |         assert "Invalid dice notation" in str(exc_info.value)
 55 | 
 56 |     @pytest.mark.asyncio
 57 |     async def test_roll_dice_invalid_notation_no_d(self, dice_tool):
 58 |         """Test notation without 'd' raises ValidationError."""
 59 |         with pytest.raises(ValidationToolError) as exc_info:
 60 |             await dice_tool.execute(notation="2x6")
 61 | 
 62 |         assert "Invalid dice notation" in str(exc_info.value)
 63 | 
 64 |     @pytest.mark.asyncio
 65 |     async def test_roll_dice_zero_dice_count(self, dice_tool):
 66 |         """Test zero dice count raises ValidationError."""
 67 |         with pytest.raises(ValidationToolError) as exc_info:
 68 |             await dice_tool.execute(notation="0d6")
 69 | 
 70 |         assert "Dice count must be greater than 0" in str(exc_info.value)
 71 | 
 72 |     @pytest.mark.asyncio
 73 |     async def test_roll_dice_zero_sides(self, dice_tool):
 74 |         """Test zero sides raises ValidationError."""
 75 |         with pytest.raises(ValidationToolError) as exc_info:
 76 |             await dice_tool.execute(notation="1d0")
 77 | 
 78 |         assert "Number of sides must be greater than 0" in str(exc_info.value)
 79 | 
 80 |     @pytest.mark.asyncio
 81 |     async def test_roll_dice_too_many_dice(self, dice_tool):
 82 |         """Test too many dice raises ValidationError."""
 83 |         with pytest.raises(ValidationToolError) as exc_info:
 84 |             await dice_tool.execute(notation="101d6")
 85 | 
 86 |         assert "Dice count must not exceed 100" in str(exc_info.value)
 87 | 
 88 |     @pytest.mark.asyncio
 89 |     async def test_roll_dice_too_many_sides(self, dice_tool):
 90 |         """Test too many sides raises ValidationError."""
 91 |         with pytest.raises(ValidationToolError) as exc_info:
 92 |             await dice_tool.execute(notation="1d1001")
 93 | 
 94 |         assert "Number of sides must not exceed 1000" in str(exc_info.value)
 95 | 
 96 |     @pytest.mark.asyncio
 97 |     async def test_roll_dice_random_text(self, dice_tool):
 98 |         """Test random text raises ValidationError."""
 99 |         with pytest.raises(ValidationToolError) as exc_info:
100 |             await dice_tool.execute(notation="abc")
101 | 
102 |         assert "Invalid dice notation" in str(exc_info.value)
103 | 
104 |     def test_format_result_single_die(self, dice_tool):
105 |         """Test formatting result for single die."""
106 |         from src.mcp_server.models import DiceRollResponse
107 | 
108 |         response = DiceRollResponse(values=[15], total=15, notation="1d20")
109 |         formatted = dice_tool.format_result(response)
110 | 
111 |         assert "🎲" in formatted
112 |         assert "1d20" in formatted
113 |         assert "**15**" in formatted
114 | 
115 |     def test_format_result_multiple_dice(self, dice_tool):
116 |         """Test formatting result for multiple dice."""
117 |         from src.mcp_server.models import DiceRollResponse
118 | 
119 |         response = DiceRollResponse(values=[4, 2, 6], total=12, notation="3d6")
120 |         formatted = dice_tool.format_result(response)
121 | 
122 |         assert "🎲" in formatted
123 |         assert "3d6" in formatted
124 |         assert "[4, 2, 6]" in formatted
125 |         assert "**12**" in formatted
126 | 
127 |     @pytest.mark.asyncio
128 |     async def test_safe_execute_success(self, dice_tool):
129 |         """Test safe_execute returns proper success format."""
130 |         result = await dice_tool.safe_execute(notation="2d6")
131 | 
132 |         assert "content" in result
133 |         assert "isError" in result
134 |         assert result["isError"] is False
135 |         assert len(result["content"]) == 1
136 |         assert result["content"][0]["type"] == "text"
137 |         assert "🎲" in result["content"][0]["text"]
138 | 
139 |     @pytest.mark.asyncio
140 |     async def test_safe_execute_error(self, dice_tool):
141 |         """Test safe_execute returns proper error format."""
142 |         result = await dice_tool.safe_execute(notation="invalid")
143 | 
144 |         assert "content" in result
145 |         assert "isError" in result
146 |         assert result["isError"] is True
147 |         assert len(result["content"]) == 1
148 |         assert result["content"][0]["type"] == "text"
149 |         assert "Invalid input" in result["content"][0]["text"]
150 | 
151 |     @pytest.mark.asyncio
152 |     async def test_roll_dice_case_insensitive(self, dice_tool):
153 |         """Test dice notation is case insensitive."""
154 |         result1 = await dice_tool.execute(notation="2D6")
155 |         result2 = await dice_tool.execute(notation="2d6")
156 | 
157 |         # Both should work and produce valid results
158 |         assert len(result1.values) == 2
159 |         assert len(result2.values) == 2
160 |         assert all(1 <= v <= 6 for v in result1.values)
161 |         assert all(1 <= v <= 6 for v in result2.values)


--------------------------------------------------------------------------------
/tests/test_tools/test_weather.py:
--------------------------------------------------------------------------------
  1 | """Tests for the weather tool."""
  2 | 
  3 | import pytest
  4 | from unittest.mock import AsyncMock, patch
  5 | import httpx
  6 | 
  7 | from src.mcp_server.tools.weather import WeatherTool
  8 | from src.mcp_server.tools.base import ValidationToolError, ExternalServiceError, ToolError
  9 | from tests.fixtures.mcp_messages import WeatherAPIFixtures
 10 | 
 11 | 
 12 | class TestWeatherTool:
 13 |     """Test suite for WeatherTool."""
 14 | 
 15 |     @pytest.fixture
 16 |     def weather_tool(self):
 17 |         """Create a WeatherTool instance for testing."""
 18 |         return WeatherTool()
 19 | 
 20 |     @pytest.fixture
 21 |     def mock_http_client(self):
 22 |         """Create a mock HTTP client."""
 23 |         client = AsyncMock()
 24 |         return client
 25 | 
 26 |     def test_parse_location_known_city(self, weather_tool):
 27 |         """Test parsing known city names."""
 28 |         lat, lon = weather_tool.parse_location("San Francisco")
 29 |         assert lat == 37.7749
 30 |         assert lon == -122.4194
 31 | 
 32 |         lat, lon = weather_tool.parse_location("new york")
 33 |         assert lat == 40.7128
 34 |         assert lon == -74.0060
 35 | 
 36 |     def test_parse_location_coordinates(self, weather_tool):
 37 |         """Test parsing coordinate strings."""
 38 |         lat, lon = weather_tool.parse_location("37.7749,-122.4194")
 39 |         assert lat == 37.7749
 40 |         assert lon == -122.4194
 41 | 
 42 |         lat, lon = weather_tool.parse_location("51.5074, -0.1278")
 43 |         assert lat == 51.5074
 44 |         assert lon == -0.1278
 45 | 
 46 |     def test_parse_location_invalid(self, weather_tool):
 47 |         """Test parsing invalid locations raises ToolError."""
 48 |         with pytest.raises(ToolError) as exc_info:
 49 |             weather_tool.parse_location("Unknown City")
 50 | 
 51 |         assert "Unknown location" in str(exc_info.value)
 52 | 
 53 |     def test_parse_location_invalid_coordinates(self, weather_tool):
 54 |         """Test parsing invalid coordinates raises ToolError."""
 55 |         with pytest.raises(ToolError):
 56 |             weather_tool.parse_location("abc,def")
 57 | 
 58 |         with pytest.raises(ToolError):
 59 |             weather_tool.parse_location("200,300")  # Out of range
 60 | 
 61 |     def test_weather_code_to_text(self, weather_tool):
 62 |         """Test weather code conversion."""
 63 |         assert weather_tool.weather_code_to_text(0) == "Clear sky"
 64 |         assert weather_tool.weather_code_to_text(61) == "Slight rain"
 65 |         assert weather_tool.weather_code_to_text(95) == "Thunderstorm"
 66 |         assert "Unknown weather condition" in weather_tool.weather_code_to_text(999)
 67 | 
 68 |     @pytest.mark.asyncio
 69 |     async def test_execute_success_known_city(self, weather_tool, mock_http_client):
 70 |         """Test successful weather retrieval for known city."""
 71 |         # Mock the API response
 72 |         mock_response = WeatherAPIFixtures.current_weather_response(
 73 |             temperature=18.5, weather_code=2, wind_speed=12.3, humidity=65.0
 74 |         )
 75 | 
 76 |         with patch.object(weather_tool, 'make_request', return_value=mock_response):
 77 |             result = await weather_tool.execute(location="San Francisco")
 78 | 
 79 |             assert result.location == "San Francisco"
 80 |             assert result.temperature == 18.5
 81 |             assert result.condition == "Partly cloudy"
 82 |             assert result.wind_speed == 12.3
 83 |             assert result.humidity == 65.0
 84 | 
 85 |     @pytest.mark.asyncio
 86 |     async def test_execute_success_coordinates(self, weather_tool):
 87 |         """Test successful weather retrieval using coordinates."""
 88 |         mock_response = WeatherAPIFixtures.current_weather_response()
 89 | 
 90 |         with patch.object(weather_tool, 'make_request', return_value=mock_response):
 91 |             result = await weather_tool.execute(location="37.7749,-122.4194")
 92 | 
 93 |             assert result.location == "37.7749,-122.4194"
 94 |             assert result.temperature == 20.0
 95 |             assert result.condition == "Clear sky"
 96 | 
 97 |     @pytest.mark.asyncio
 98 |     async def test_execute_invalid_location(self, weather_tool):
 99 |         """Test execution with invalid location."""
100 |         with pytest.raises(ToolError) as exc_info:
101 |             await weather_tool.execute(location="Unknown City")
102 | 
103 |         assert "Unknown location" in str(exc_info.value)
104 | 
105 |     @pytest.mark.asyncio
106 |     async def test_execute_empty_location(self, weather_tool):
107 |         """Test execution with empty location."""
108 |         with pytest.raises(ToolError) as exc_info:
109 |             await weather_tool.execute(location="")
110 | 
111 |         assert "Missing required parameter" in str(exc_info.value)
112 | 
113 |     @pytest.mark.asyncio
114 |     async def test_execute_api_timeout(self, weather_tool):
115 |         """Test handling of API timeout."""
116 |         with patch.object(weather_tool, 'make_request', side_effect=httpx.TimeoutException("Timeout")):
117 |             with pytest.raises(ExternalServiceError) as exc_info:
118 |                 await weather_tool.execute(location="San Francisco")
119 | 
120 |             assert "timeout" in str(exc_info.value).lower()
121 | 
122 |     @pytest.mark.asyncio
123 |     async def test_execute_api_http_error(self, weather_tool):
124 |         """Test handling of HTTP errors."""
125 |         error = httpx.HTTPStatusError(
126 |             "500 Server Error",
127 |             request=httpx.Request("GET", "http://test"),
128 |             response=httpx.Response(500, text="Server Error")
129 |         )
130 | 
131 |         with patch.object(weather_tool, 'make_request', side_effect=error):
132 |             with pytest.raises(ExternalServiceError) as exc_info:
133 |                 await weather_tool.execute(location="San Francisco")
134 | 
135 |             assert "500" in str(exc_info.value)
136 | 
137 |     @pytest.mark.asyncio
138 |     async def test_execute_incomplete_data(self, weather_tool):
139 |         """Test handling of incomplete API data."""
140 |         incomplete_response = {"current": {"time": "2025-07-07T14:30:00Z"}}
141 | 
142 |         with patch.object(weather_tool, 'make_request', return_value=incomplete_response):
143 |             with pytest.raises(ExternalServiceError) as exc_info:
144 |                 await weather_tool.execute(location="San Francisco")
145 | 
146 |             assert "Incomplete weather data" in str(exc_info.value)
147 | 
148 |     @pytest.mark.asyncio
149 |     async def test_execute_no_current_data(self, weather_tool):
150 |         """Test handling of missing current weather data."""
151 |         no_current_response = {"forecast": {}}
152 | 
153 |         with patch.object(weather_tool, 'make_request', return_value=no_current_response):
154 |             with pytest.raises(ExternalServiceError) as exc_info:
155 |                 await weather_tool.execute(location="San Francisco")
156 | 
157 |             assert "No current weather data" in str(exc_info.value)
158 | 
159 |     def test_format_result(self, weather_tool):
160 |         """Test formatting weather result for display."""
161 |         from src.mcp_server.models import WeatherResponse
162 | 
163 |         response = WeatherResponse(
164 |             location="San Francisco",
165 |             temperature=18.5,
166 |             condition="Partly cloudy",
167 |             wind_speed=12.3,
168 |             humidity=65.0,
169 |             timestamp="2025-07-07T14:30:00Z"
170 |         )
171 | 
172 |         formatted = weather_tool.format_result(response)
173 | 
174 |         assert "🌤️" in formatted
175 |         assert "San Francisco" in formatted
176 |         assert "18.5°C" in formatted
177 |         assert "Partly cloudy" in formatted
178 |         assert "12.3 km/h" in formatted
179 |         assert "65.0%" in formatted
180 | 
181 |     def test_format_result_no_humidity(self, weather_tool):
182 |         """Test formatting weather result without humidity."""
183 |         from src.mcp_server.models import WeatherResponse
184 | 
185 |         response = WeatherResponse(
186 |             location="Test City",
187 |             temperature=20.0,
188 |             condition="Clear sky",
189 |             wind_speed=10.0,
190 |             humidity=None,
191 |             timestamp=None
192 |         )
193 | 
194 |         formatted = weather_tool.format_result(response)
195 | 
196 |         assert "🌤️" in formatted
197 |         assert "Test City" in formatted
198 |         assert "20.0°C" in formatted
199 |         assert "💧" not in formatted  # Humidity should not appear
200 | 
201 |     @pytest.mark.asyncio
202 |     async def test_safe_execute_success(self, weather_tool):
203 |         """Test safe_execute returns proper success format."""
204 |         mock_response = WeatherAPIFixtures.current_weather_response()
205 | 
206 |         with patch.object(weather_tool, 'make_request', return_value=mock_response):
207 |             result = await weather_tool.safe_execute(location="San Francisco")
208 | 
209 |             assert "content" in result
210 |             assert "isError" in result
211 |             assert result["isError"] is False
212 |             assert len(result["content"]) == 1
213 |             assert result["content"][0]["type"] == "text"
214 |             assert "🌤️" in result["content"][0]["text"]
215 | 
216 |     @pytest.mark.asyncio
217 |     async def test_safe_execute_error(self, weather_tool):
218 |         """Test safe_execute returns proper error format."""
219 |         result = await weather_tool.safe_execute(location="Unknown City")
220 | 
221 |         assert "content" in result
222 |         assert "isError" in result
223 |         assert result["isError"] is True
224 |         assert len(result["content"]) == 1
225 |         assert result["content"][0]["type"] == "text"
226 |         assert "Unknown location" in result["content"][0]["text"]
227 | 
228 |     @pytest.mark.asyncio
229 |     async def test_cleanup(self, weather_tool):
230 |         """Test cleanup method closes HTTP client."""
231 |         # Mock the HTTP client
232 |         mock_client = AsyncMock()
233 |         weather_tool._http_client = mock_client
234 |         
235 |         await weather_tool.cleanup()
236 |         
237 |         mock_client.aclose.assert_called_once()
238 |         assert weather_tool._http_client is None


--------------------------------------------------------------------------------

